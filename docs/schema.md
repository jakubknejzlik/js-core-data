## Schema

`js-core-data` is ORM and needs to know schema of it's model. This section describes how to define entities and their relationships.
  

### Creating entity

Creating new entity with given name and attributes is done with `createEntity` function:

`database.createEntity(name, attributes[, options])`

- `name` - use capitalized name such as `User`, `Book`, `Car` etc.
- `attributes` - attribute definition (see [Attributes](#attributes))
- `options` 
    - `class` - entity class used for [Subclassing](#subclasses) 

### Attributes

Attribute definition for entity is object. Every key define attribute name and value could be string (attribute type) or object (attribute definition)
 
Example: 

```
database.defineEntity('User',{
    uid: {
        type: 'uuid',
        default: 'abcd',
        unique: true,
        indexed: true
    },
    firstname: 'string'
})
```

#### Attribute definition structure

- `type` - 
- `default` - specify default value (used when entity is created)
- `unique` - create unique index for this attribute
- `indexed` - create index for this attribute
- `transient` - attribute is not persisted to database, getter function needs to be provided (see [Subclasses](#subclasses))
- `values` - array of values used for `enum` type

#### Supported attribute types

- `string` - textual attribute
- `text` - textual attribute for long texts
- `int`, `integer`
- `bigint`
- `double`
- `float`
- `decimal`
- `bool`, `boolean`
- `date` - Date object, stored as datetime
- `timestamp` - Date object, stored as bigint
- `enum` - enumerable values
- `uuid` - unique identifier, you can use default value `uuidv4` for autogenerating unique identifier
- `transformable` - custom object (this object is saved by JSON.stingify and retreived with JSON.parse)
 


## Subclasses

Every entity is instnace of ManagedObject class. You can implement custom behaviour (custom getters/settings/validators, etc.) by providing subclass in entity definition options.


```
var ManagedObject = require('js-core-data').ManagedObject;

function Book() {
}

util.inherits(Book, ManagedObject);

MyStream.prototype.willSave = function() {
    AttributeDescription.__super__.constructor.call(this);
}
```

or with coffeescript

```
ManagedObject = require('js-core-data').ManagedObject

class Book extends ManagedObject
    willSave: ()->
        super()
```

and then assign subclass with entity definition

```
database.defineEntity('Book',{
    title: 'string'
},{
    class: Book
})
```


## Relationships

Relationships oneToMany and manyToMany are supported (oneToOne isn't). You can specify relationships with methods:

- `defineRelationshipsOneToMany(Source, Target, name, inverseName[, options])`
- `defineRelationshipsManyToOne(Source, Target, name, inverseName[, options])`
- `defineRelationshipsManyToMany(Source, Target, name, inverseName[, options])`

Example:

```
var database = ...;

var Person = database.defineEntity('Person',{name: 'string'});
var Company = database.defineEntity('Company',{name: 'string'});

database.defineRelationshipOneToMany(Company, Person, 'employees', 'company');
// or: database.defineRelationshipManyToOne(Person, Company, 'company', 'employees');

database.defineRelationshipManyToMany(Person, Person, 'collegues', 'collegues');
```

- `Source` - source entity definition
- `Target` - target entity definition
- `name` - name of relationship
- `inverseName` - relationship inverse name
- `options`
    - `onDelete` - specify action taken when Source object is deleted (supported values: `cascade`, `nullify`, `deny`)

Inverse name is mandatory and is used for traversing schema from both directions.

If you specify relationship name, additional methods are autogenerated for adding/removing items.

- `employees` toMany relationship generates methods
    - `addEmployee(employee)` - add single object
    - `addEmployees(employees)` - add array of objects
    - `removeEmployee(employee)` - remove single object
    - `removeEmployees(employees)` - remove array of objects
- `company` inversed toOne relationship generates method
    - `setCompany(company)` - which sets object (setting null removes the relationship)


## Versioning

`js-core-data` supports versioning by creating models. Every model has same methods for schema definition as database client. Even if you don't use versioning, database client has schema definition stored in `default` model.

You can create new model version with:

```
var model = database.createModel('v1');

model.defineEntity('Book',{
    title: 'string'
})

database.setModelVersion('v1'); // you need to specify which version to use
```

You can migrate between model versions. For more information see [Migrations](migrations.md)

## YAML schema

Sometimes it's more convenient to define schema in some sort of string and be able parse it.

For example you can have this schema written in yaml:
```
Company:
  columns:
    name: string
  relationships:
    employees:
      entity: Person
      toMany: true # default is false
      inverse: company

Person:
  columns:
    firstname: string
    lastname: string
  relationships:
    company:
      entity: Company
      inverse: employees
    friends: # many-2-many
      entity: Person
      toMany: true
      inverse: friends 
```

Then you can create model from yaml file this way:
```
var entityDefinitions = {
    Person: PersonClass // PersonClass should be subclass of ManagedObject
}
database.createModelFromYaml(fs.readFileSync('path/to/file.yml')),entityDefinitions,'v1')
```

Empty object `entityDefinitions` is place where you can inject subclasses (object key is entity name).

## Next

Continue to [Fetching](fetching.md)