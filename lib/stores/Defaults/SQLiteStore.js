// Generated by CoffeeScript 1.10.0
(function() {
  var GenericPool, GenericSQLStore, ManagedObjectID, PersistentStoreRequest, Predicate, SQLiteConnection, SQLiteStore, Transaction, _, async, e, error1, sqlite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GenericSQLStore = require('./GenericSQLStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  try {
    require('sqlite3');
  } catch (error1) {
    e = error1;
    throw new Error('sqlite3 module is required to user SQLite storage, please install it by running npm install --save sqlite3');
  }

  sqlite = require('sqlite3');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  SQLiteStore = (function(superClass) {
    extend(SQLiteStore, superClass);

    function SQLiteStore() {
      return SQLiteStore.__super__.constructor.apply(this, arguments);
    }

    SQLiteStore.prototype.createConnection = function() {
      return new SQLiteConnection(this.URL, this);
    };

    SQLiteStore.prototype.createSchemaQueries = function(options) {
      var entity, key, objectModel, ref, sqls;
      if (options == null) {
        options = {};
      }
      objectModel = this.storeCoordinator.objectModel;
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        sqls = sqls.concat(this.createEntityQueries(entity, options.force));
      }
      sqls.push('CREATE TABLE IF NOT EXISTS `_meta` (`key` varchar(10) NOT NULL,`value` varchar(250) NOT NULL,PRIMARY KEY (`key`))');
      sqls.push('INSERT OR IGNORE INTO `_meta` VALUES(\'version\',\'' + objectModel.version + '\')');
      return sqls;
    };

    SQLiteStore.prototype.createEntityQueries = function(entity, force) {
      var attribute, columnDefinition, i, index, inversedRelationship, j, k, key, len, len1, len2, parts, ref, ref1, ref2, ref3, reflexiveRelationship, reflexiveTableName, relationship, sql, sqls, tableName;
      if (force == null) {
        force = false;
      }
      sqls = [];
      tableName = this._formatTableName(entity.name);
      parts = ['`_id` INTEGER PRIMARY KEY AUTOINCREMENT'];
      ref = entity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columnDefinition = this._columnDefinitionForAttribute(attribute);
        if (columnDefinition) {
          parts.push(columnDefinition);
        } else {
          throw new Error('unknown attribute type ' + attribute.type);
        }
      }
      ref1 = entity.relationships;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        relationship = ref1[j];
        if (!relationship.toMany) {
          parts.push('`' + relationship.name + '_id` int(11) DEFAULT NULL');
        }
      }
      if (force) {
        sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
      }
      sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
      sql += parts.join(',');
      sql += ')';
      ref2 = this._indexesForEntity(entity);
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        index = ref2[k];
        sql += ";CREATE INDEX IF NOT EXISTS `" + index.name + '` ON `' + tableName + '` (`' + index.columns.join('`,`') + "`)";
      }
      sqls.push(sql);
      ref3 = entity.relationships;
      for (key in ref3) {
        relationship = ref3[key];
        if (relationship.toMany) {
          inversedRelationship = relationship.inverseRelationship();
          if (inversedRelationship.toMany) {
            reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
            reflexiveTableName = this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name;
            if (force) {
              sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
            }
            sqls.push('CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))');
          }
        }
      }
      return sqls;
    };

    SQLiteStore.prototype.createMigrationQueries = function(migration) {
      var attribute, attributeName, attributes, change, entity, entityName, inverseRelationship, modelFrom, modelTo, oldEntity, oldReflexiveTableName, oldRelationship, ref, ref1, ref2, ref3, reflexiveRelationship, reflexiveTableName, relationship, relationshipName, relationships, sqls;
      sqls = [];
      modelTo = migration.modelTo;
      modelFrom = migration.modelFrom;
      ref = migration.entitiesChanges;
      for (entityName in ref) {
        change = ref[entityName];
        switch (change) {
          case '+':
            sqls = sqls.concat(this.createEntityQueries(modelTo.getEntity(entityName)));
            break;
          case '-':
            sqls.push('DROP TABLE IF EXISTS `' + this._formatTableName(entityName) + '`');
            break;
          default:
            sqls.push('ALTER TABLE `' + this._formatTableName(change) + '` RENAME TO `' + this._formatTableName(entityName) + '`');
        }
      }
      ref1 = migration.attributesChanges;
      for (entityName in ref1) {
        attributes = ref1[entityName];
        entity = modelTo.getEntity(entityName);
        for (attributeName in attributes) {
          change = attributes[attributeName];
          attribute = entity.getAttribute(attributeName);
          switch (change) {
            case '+':
              sqls.push('ALTER TABLE `' + this._formatTableName(entityName) + '` ADD COLUMN ' + this._columnDefinitionForAttribute(attribute));
              break;
            case '-':
              throw new Error('drop column not implemented in sqlite3');
              break;
            default:
              throw new Error('rename column not implemented in sqlite3');
          }
        }
      }
      ref2 = migration.relationshipsChanges;
      for (entityName in ref2) {
        relationships = ref2[entityName];
        entity = modelTo.getEntity(entityName);
        oldEntity = modelFrom.getEntity(entityName);
        for (relationshipName in relationships) {
          change = relationships[relationshipName];
          relationship = entity.getRelationship(relationshipName);
          inverseRelationship = relationship.inverseRelationship();
          if (inverseRelationship.toMany) {
            ref3 = [inverseRelationship, relationship], relationship = ref3[0], inverseRelationship = ref3[1];
          }
          if (relationship.toMany && inverseRelationship.toMany) {
            reflexiveRelationship = this._relationshipByPriority(relationship, inverseRelationship);
            reflexiveTableName = this._formatManyToManyRelationshipTableName(relationship);
            switch (change) {
              case '+':
                sqls.push('CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))');
                break;
              case '-':
                sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
                break;
              default:
                oldRelationship = oldEntity.getRelationship(change);
                oldReflexiveTableName = this._formatManyToManyRelationshipTableName(oldRelationship);
                sqls.push('ALTER TABLE `' + oldReflexiveTableName + '` RENAME TO `' + reflexiveTableName + '`');
            }
          } else if (relationship.toMany) {
            switch (change) {
              case '+':
                sqls.push('ALTER TABLE `' + this._formatTableName(entity.name) + '` ADD COLUMN `' + relationship.name + '_id` int(11) DEFAULT NULL');
                break;
              case '-':
                throw new Error('drop relationship oneToMany not implemented in sqlite3');
                break;
              default:
                throw new Error('rename relationship oneToMany not implemented in sqlite3');
            }
          }
        }
      }
      return sqls;
    };

    return SQLiteStore;

  })(GenericSQLStore);

  SQLiteConnection = (function(superClass) {
    extend(SQLiteConnection, superClass);

    function SQLiteConnection(url, store, settings) {
      var ref, ref1;
      this.store = store;
      this.sendRawQuery = bind(this.sendRawQuery, this);
      this.pool = GenericPool.Pool({
        name: "sqlite",
        create: (function(_this) {
          return function(callback) {
            var connection;
            return connection = new sqlite.Database(url.replace('sqlite://', ''), function(err) {
              connection.on('trace', function(query) {
                var ref, ref1;
                if ((ref = _this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
                  return _this.store.globals.logging(query);
                }
              });
              return callback(err, connection);
            });
          };
        })(this),
        destroy: function(connection) {
          return connection.close();
        },
        max: 1,
        idleTimeoutMillis: (ref = settings != null ? settings.idletimeoutMillis : void 0) != null ? ref : 60 * 1000,
        reapIntervalMillis: (ref1 = settings != null ? settings.reapIntervalMillis : void 0) != null ? ref1 : 5 * 1000
      });
    }

    SQLiteConnection.prototype.sendRawQuery = function(query, params, callback) {
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      return this.pool.acquire((function(_this) {
        return function(err, conn) {
          var error, error2;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          try {
            params = params || {};
            return conn.all(query, params, function(err, results) {
              _this.pool.release(conn);
              return typeof callback === "function" ? callback(err, results) : void 0;
            });
          } catch (error2) {
            error = error2;
            _this.pool.release(conn);
            return typeof callback === "function" ? callback(error) : void 0;
          }
        };
      })(this));
    };

    SQLiteConnection.prototype.sendQuery = function(query, params, callback) {
      var err, error2, sql;
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      try {
        sql = query.getSQL();
        return this.sendRawQuery(sql, params, callback);
      } catch (error2) {
        err = error2;
        return callback(err);
      }
    };

    SQLiteConnection.prototype.createTransaction = function(callback) {
      return this.pool.acquire((function(_this) {
        return function(err, connection) {
          if (err) {
            return callback(err);
          }
          return callback(new Transaction(connection, _this.store));
        };
      })(this));
    };

    SQLiteConnection.prototype.releaseTransaction = function(transaction) {
      return this.pool.release(transaction.connection);
    };

    return SQLiteConnection;

  })(Object);

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    function Transaction(connection1, store) {
      this.connection = connection1;
      this.store = store;
      this.started = false;
      this.autoRollback = true;
      this.debug = false;
    }

    Transaction.prototype.ensureBegin = function(callback) {
      if (this.started) {
        return callback();
      }
      this.started = true;
      return this.connection.run('BEGIN', function(err) {
        return callback(err);
      });
    };

    Transaction.prototype.sendQuery = function(query, params, callback) {
      var q;
      if (typeof params === 'function') {
        callback = params;
        params = void 0;
      }
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      q = typeof query === 'string' ? query : query.getSQL();
      return this.ensureBegin((function(_this) {
        return function(err) {
          if (err) {
            if (self.autoRollback) {
              return _this.rollback(function() {
                return callback(err);
              });
            } else {
              return callback(err);
            }
          }
          params = params || {};
          return _this.connection.run(q, params, function(err, results) {
            results = results || {};
            results.insertId = this.lastID;
            if (callback) {
              return callback(err, results);
            }
          });
        };
      })(this));
    };

    Transaction.prototype.commit = function(callback) {
      return this.connection.run('COMMIT', callback);
    };

    Transaction.prototype.rollback = function(callback) {
      return this.connection.run('ROLLBACK', callback);
    };

    return Transaction;

  })(Object);

  module.exports = SQLiteStore;

}).call(this);
