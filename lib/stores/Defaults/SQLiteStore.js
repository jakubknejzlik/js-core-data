// Generated by CoffeeScript 1.9.3
(function() {
  var GenericPool, GenericSQLStore, ManagedObjectID, PersistentStoreRequest, Predicate, SQLiteConnection, SQLiteStore, Transaction, _, async, e, sqlite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GenericSQLStore = require('./GenericSQLStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  try {
    require('sqlite3');
  } catch (_error) {
    e = _error;
    throw new Error('sqlite3 module is required to user SQLite storage, please install it by running npm install --save sqlite3');
  }

  sqlite = require('sqlite3');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  SQLiteStore = (function(superClass) {
    extend(SQLiteStore, superClass);

    function SQLiteStore() {
      return SQLiteStore.__super__.constructor.apply(this, arguments);
    }

    SQLiteStore.prototype.createConnection = function() {
      return new SQLiteConnection(this.URL, this);
    };

    SQLiteStore.prototype.createSchemaQueries = function(options) {
      var attribute, columnDefinition, entity, i, index, inversedRelationship, j, k, key, len, len1, len2, objectModel, parts, ref, ref1, ref2, ref3, ref4, reflexiveRelationship, reflexiveTableName, relationship, schema, sql, sqls, tableName;
      if (options == null) {
        options = {};
      }
      objectModel = this.storeCoordinator.objectModel;
      schema = {};
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        tableName = this._formatTableName(entity.name);
        parts = ['`_id` INTEGER PRIMARY KEY AUTOINCREMENT'];
        ref1 = entity.attributes;
        for (i = 0, len = ref1.length; i < len; i++) {
          attribute = ref1[i];
          columnDefinition = this._columnDefinitionForAttribute(attribute);
          if (columnDefinition) {
            parts.push(columnDefinition);
          } else {
            throw new Error('unknown attribute type ' + attribute.type);
          }
        }
        ref2 = entity.relationships;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          relationship = ref2[j];
          if (!relationship.toMany) {
            parts.push('`' + relationship.name + '_id` int(11) DEFAULT NULL');
          }
        }
        if (options.force) {
          sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
        }
        sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
        sql += parts.join(',');
        sql += ')';
        ref3 = this._indexesForEntity(entity);
        for (k = 0, len2 = ref3.length; k < len2; k++) {
          index = ref3[k];
          sql += ";CREATE INDEX IF NOT EXISTS `" + index.name + '` ON `' + tableName + '` (`' + index.columns.join('`,`') + "`)";
        }
        schema[tableName] = sql;
        ref4 = entity.relationships;
        for (key in ref4) {
          relationship = ref4[key];
          if (relationship.toMany) {
            inversedRelationship = relationship.inverseRelationship();
            if (inversedRelationship.toMany) {
              reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
              reflexiveTableName = this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name;
              if (options.force) {
                sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
              }
              schema[reflexiveTableName] = 'CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))';
            }
          }
        }
      }
      for (key in schema) {
        sql = schema[key];
        sqls.push(sql);
      }
      sqls.push('CREATE TABLE IF NOT EXISTS `_meta` (`key` varchar(10) NOT NULL,`value` varchar(250) NOT NULL,PRIMARY KEY (`key`))');
      sqls.push('INSERT OR IGNORE INTO `_meta` VALUES(\'version\',\'' + objectModel.version + '\')');
      return sqls;
    };

    return SQLiteStore;

  })(GenericSQLStore);

  SQLiteConnection = (function(superClass) {
    extend(SQLiteConnection, superClass);

    function SQLiteConnection(url, store, settings) {
      var ref, ref1;
      this.store = store;
      this.sendRawQuery = bind(this.sendRawQuery, this);
      this.pool = GenericPool.Pool({
        name: "sqlite",
        create: (function(_this) {
          return function(callback) {
            var connection;
            return connection = new sqlite.Database(url.replace('sqlite://', ''), function(err) {
              connection.on('trace', function(query) {
                var ref, ref1;
                if ((ref = _this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
                  return _this.store.globals.logging(query);
                }
              });
              return callback(err, connection);
            });
          };
        })(this),
        destroy: function(connection) {
          return connection.close();
        },
        max: 1,
        idleTimeoutMillis: (ref = settings != null ? settings.idletimeoutMillis : void 0) != null ? ref : 60 * 1000,
        reapIntervalMillis: (ref1 = settings != null ? settings.reapIntervalMillis : void 0) != null ? ref1 : 5 * 1000
      });
    }

    SQLiteConnection.prototype.sendRawQuery = function(query, params, callback) {
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      return this.pool.acquire((function(_this) {
        return function(err, conn) {
          var error;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          try {
            params = params || {};
            return conn.all(query, params, function(err, results) {
              _this.pool.release(conn);
              return typeof callback === "function" ? callback(err, results) : void 0;
            });
          } catch (_error) {
            error = _error;
            _this.pool.release(conn);
            return typeof callback === "function" ? callback(error) : void 0;
          }
        };
      })(this));
    };

    SQLiteConnection.prototype.sendQuery = function(query, params, callback) {
      var err, sql;
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      try {
        sql = query.getSQL();
        return this.sendRawQuery(sql, params, callback);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    SQLiteConnection.prototype.createTransaction = function(callback) {
      return this.pool.acquire((function(_this) {
        return function(err, connection) {
          if (err) {
            return callback(err);
          }
          return callback(new Transaction(connection, _this.store));
        };
      })(this));
    };

    SQLiteConnection.prototype.releaseTransaction = function(transaction) {
      return this.pool.release(transaction.connection);
    };

    return SQLiteConnection;

  })(Object);

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    function Transaction(connection1, store) {
      this.connection = connection1;
      this.store = store;
      this.started = false;
      this.autoRollback = true;
      this.debug = false;
    }

    Transaction.prototype.ensureBegin = function(callback) {
      if (this.started) {
        return callback();
      }
      this.started = true;
      return this.connection.run('BEGIN', function(err) {
        return callback(err);
      });
    };

    Transaction.prototype.sendQuery = function(query, params, callback) {
      var q;
      if (typeof params === 'function') {
        callback = params;
        params = void 0;
      }
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      q = typeof query === 'string' ? query : query.getSQL();
      return this.ensureBegin((function(_this) {
        return function(err) {
          if (err) {
            if (self.autoRollback) {
              return _this.rollback(function() {
                return callback(err);
              });
            } else {
              return callback(err);
            }
          }
          params = params || {};
          return _this.connection.run(q, params, function(err, results) {
            results = results || {};
            results.insertId = this.lastID;
            if (callback) {
              return callback(err, results);
            }
          });
        };
      })(this));
    };

    Transaction.prototype.commit = function(callback) {
      return this.connection.run('COMMIT', callback);
    };

    Transaction.prototype.rollback = function(callback) {
      return this.connection.run('ROLLBACK', callback);
    };

    return Transaction;

  })(Object);

  module.exports = SQLiteStore;

}).call(this);
