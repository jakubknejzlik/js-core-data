// Generated by CoffeeScript 1.10.0
(function() {
  var FetchRequest, GenericSQLStore, IncrementalStore, ManagedObjectContext, ManagedObjectID, PersistentStoreCoordinator, PersistentStoreRequest, Predicate, SQLConnectionPool, SortDescriptor, _, async, moment, squel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  IncrementalStore = require('./../IncrementalStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  FetchRequest = require('./../../FetchRequest');

  SortDescriptor = require('./../../FetchClasses/SortDescriptor');

  squel = require('squel');

  moment = require('moment');

  PersistentStoreCoordinator = require('../../PersistentStoreCoordinator');

  ManagedObjectContext = require('../../ManagedObjectContext');

  SQLConnectionPool = require('./SQLConnectionPool');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  GenericSQLStore = (function(superClass) {
    extend(GenericSQLStore, superClass);

    GenericSQLStore.prototype.tableAlias = 'SELF';

    GenericSQLStore.prototype.quoteSymbol = '"';

    function GenericSQLStore(storeCoordinator, URL, globals) {
      this.storeCoordinator = storeCoordinator;
      this.URL = URL;
      this.globals = globals;
      if (this.storeCoordinator) {
        this.connectionPool = new SQLConnectionPool(this.URL, (function(_this) {
          return function(url) {
            return _this.createConnection(url);
          };
        })(this), this, this.globals);
      }
      this.permanentIDsCache = {};
    }

    GenericSQLStore.prototype.createConnection = function(url) {
      throw new Error('createConnection must be overriden');
    };

    GenericSQLStore.prototype.execute = function(request, context, callback, afterInsertCallback) {
      if (!(request instanceof PersistentStoreRequest)) {
        throw new Error('request ' + request + ' is not instance of PersistentStoreRequest');
      }
      if (request.type === 'save') {
        this.connectionPool.createTransaction((function(_this) {
          return function(err, transaction) {
            if (err) {
              return callback(err);
            }
            return async.series([
              function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var formattedTableName;
                  formattedTableName = _this._formatTableName(insertedObject.entity.name);
                  return transaction.createRow(formattedTableName, function(err, rowId) {
                    if (err) {
                      return cb(err);
                    }
                    _this.permanentIDsCache[insertedObject.objectID.toString()] = rowId;
                    return cb();
                  });
                }, function(err) {
                  afterInsertCallback();
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.deletedObjects, function(deletedObject, cb) {
                  var formattedTableName, id, sql;
                  formattedTableName = _this._formatTableName(deletedObject.entity.name);
                  id = _this._recordIDForObjectID(deletedObject.objectID);
                  sql = 'DELETE FROM ' + _this.quoteSymbol + formattedTableName + _this.quoteSymbol + ' WHERE ' + _this.quoteSymbol + '_id' + _this.quoteSymbol + ' = ' + id;
                  return transaction.query(sql, function(err) {
                    return cb(err);
                  });
                }, seriesCallback);
              }, function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(insertedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.query(sql, updateValues, function(err, result) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, insertedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, insertedObject, cb);
                  }
                }, seriesCallback);
              }, function(seriesCallback) {
                return async.forEach(request.updatedObjects, function(updatedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(updatedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.query(sql, updateValues, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, updatedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, updatedObject, cb);
                  }
                }, seriesCallback);
              }
            ], function(err) {
              if (err) {
                _this.connectionPool.releaseTransaction(transaction);
                return callback(err);
              }
              return transaction.commit(function(err) {
                _this.connectionPool.releaseTransaction(transaction);
                return callback(err);
              });
            });
          };
        })(this));
      }
      if (request.type === 'fetch') {
        return this.connectionPool.query(this.sqlForFetchRequest(request), (function(_this) {
          return function(err, rows) {
            var _row, attribute, columnName, ids, j, k, l, len, len1, len2, len3, m, objectID, objectValues, ref, ref1, ref2, relationship, row;
            ids = [];
            if (err) {
              return callback(err);
            }
            if (request.resultType === FetchRequest.RESULT_TYPE.VALUES) {
              return callback(null, rows);
            }
            objectValues = {};
            for (j = 0, len = rows.length; j < len; j++) {
              row = rows[j];
              _row = {};
              ref = request.entity.attributes;
              for (k = 0, len1 = ref.length; k < len1; k++) {
                attribute = ref[k];
                _row[attribute.name] = row[attribute.name];
              }
              ref1 = request.entity.relationships;
              for (l = 0, len2 = ref1.length; l < len2; l++) {
                relationship = ref1[l];
                if (!relationship.toMany) {
                  columnName = _.singularize(relationship.name) + '_id';
                  _row[columnName] = row[columnName];
                }
              }
              objectID = _this._permanentIDForRecord(request.entity, row._id);
              ref2 = request.entity.attributes;
              for (m = 0, len3 = ref2.length; m < len3; m++) {
                attribute = ref2[m];
                _row[attribute.name] = _this.decodeValueForAttribute(_row[attribute.name], attribute);
              }
              objectValues[objectID.toString()] = _row;
              ids.push(objectID);
            }
            return callback(null, ids, objectValues);
          };
        })(this));
      }
    };

    GenericSQLStore.prototype.numberOfObjectsForFetchRequest = function(request, callback) {
      return this.connectionPool.query(this.countSqlForFetchRequest(request), (function(_this) {
        return function(err, result) {
          return callback(err, result[0].count);
        };
      })(this));
    };

    GenericSQLStore.prototype.updateQueryForUpdatedObject = function(updatedObject) {
      var attribute, e, error, formattedTableName, id, key, updateValues, updates, value, values;
      formattedTableName = this._formatTableName(updatedObject.entity.name);
      id = this._recordIDForObjectID(updatedObject.objectID);
      values = this._valuesWithRelationshipsForObject(updatedObject);
      updates = [];
      updateValues = [];
      for (key in values) {
        value = values[key];
        try {
          attribute = updatedObject.entity.getAttribute(key);
        } catch (error) {
          e = error;
          attribute = null;
        }
        if (attribute) {
          updates.push(this.quoteSymbol + key + this.quoteSymbol + ' = ?');
          updateValues.push(this.encodeValueForAttribute(attribute.encode(value), attribute));
        } else {
          updates.push(this.quoteSymbol + key + this.quoteSymbol + ' = ?');
          updateValues.push(value);
        }
      }
      if (updates.length > 0) {
        return ['UPDATE ' + this.quoteSymbol + formattedTableName + this.quoteSymbol + ' SET ' + updates.join(',') + ' WHERE ' + this.quoteSymbol + '_id' + this.quoteSymbol + ' = ' + id, updateValues];
      } else {
        return [null, null];
      }
    };

    GenericSQLStore.prototype.countSqlForFetchRequest = function(request) {
      var query, sqlString;
      query = squel.select({
        autoQuoteAliasNames: false
      }).from(this._formatTableName(request.entity.name), this.tableAlias);
      query.field('COUNT(DISTINCT SELF._id)', 'count');
      if (request.predicate) {
        query.where(this.parsePredicate(request.predicate));
      }
      sqlString = this._getRawTranslatedQueryWithJoins(query, request);
      return this.processQuery(sqlString);
    };

    GenericSQLStore.prototype.sqlForFetchRequest = function(request) {
      var attribute, column, columnName, descriptor, descriptors, field, j, k, l, len, len1, len2, name, query, ref, ref1, ref2, relationship, sqlString;
      query = squel.select({
        autoQuoteAliasNames: false
      }).from(this._formatTableName(request.entity.name), this.tableAlias);
      if (request.resultType === FetchRequest.RESULT_TYPE.MANAGED_OBJECTS) {
        query.group('SELF._id');
        query.field(this.tableAlias + '.' + this.quoteSymbol + '_id' + this.quoteSymbol, this.quoteSymbol + '_id' + this.quoteSymbol);
        ref = request.entity.attributes;
        for (j = 0, len = ref.length; j < len; j++) {
          attribute = ref[j];
          query.field(this.tableAlias + '.' + this.quoteSymbol + attribute.name + this.quoteSymbol, this.quoteSymbol + attribute.name + this.quoteSymbol);
        }
        ref1 = request.entity.relationships;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          relationship = ref1[k];
          if (!relationship.toMany) {
            columnName = _.singularize(relationship.name) + '_id';
            query.field(this.tableAlias + '.' + this.quoteSymbol + columnName + this.quoteSymbol, this.quoteSymbol + columnName + this.quoteSymbol);
          }
        }
      } else {
        if (!request.fields) {
          query.field(this.tableAlias + '.*');
        } else {
          ref2 = request.fields;
          for (name in ref2) {
            field = ref2[name];
            query.field(field, this.quoteSymbol + name + this.quoteSymbol);
          }
        }
        if (request.group) {
          query.group(request.group);
        }
      }
      if (request.predicate) {
        query.where(this.parsePredicate(request.predicate));
      }
      if (request.limit) {
        query.limit(request.limit);
      }
      if (request.offset) {
        query.offset(request.offset);
      }
      if (Array.isArray(request.sortDescriptors) && request.sortDescriptors.length > 0) {
        descriptors = request.sortDescriptors;
        for (l = 0, len2 = descriptors.length; l < len2; l++) {
          descriptor = descriptors[l];
          column = descriptor.attribute;
          if (column.indexOf(this.tableAlias + '.') === -1) {
            column = this.tableAlias + '.' + column;
          }
          query.order(column, descriptor.ascending);
        }
      }
      sqlString = this._getRawTranslatedQueryWithJoins(query, request);
      return this.processQuery(sqlString);
    };

    GenericSQLStore.prototype.parsePredicate = function(predicate) {
      return predicate.toString();
    };

    GenericSQLStore.prototype._getRawTranslatedQueryWithJoins = function(query, request) {
      var _subkeys, alreadyJoined, clearedSQLString, i, j, joinMatches, joins, key, leftJoin, len, match, replaceNameSorted, replaceNames, sqlString;
      replaceNames = {};
      joins = {};
      sqlString = query.toString();
      clearedSQLString = sqlString.replace(/\\"/g, '').replace(/"[^"]+"/g, '').replace(/\\'/g, '').replace(/'[^']+'/g, '');
      joinMatches = clearedSQLString.match(new RegExp(this.tableAlias + '(\\.[a-zA-Z_"][a-zA-Z0-9_"]*){2,}', 'g'));
      if (!joinMatches || joinMatches.length === 0) {
        return sqlString;
      }
      leftJoin = (function(_this) {
        return function(subkeys, parentEntity, path) {
          var as, inversedRelation, middleTableName, middleTableNameAlias, parentAlias, pathAlias, primaryRelation, relation, subPath;
          as = subkeys.shift();
          relation = parentEntity.getRelationship(as);
          if (!relation) {
            throw new Error('relation ' + parentEntity.name + '=>' + as + ' not found');
          }
          inversedRelation = relation.inverseRelationship();
          subPath = path + "." + as;
          if (!~alreadyJoined.indexOf(subPath)) {
            alreadyJoined.push(subPath);
            if (!replaceNames[path]) {
              replaceNames[path] = path.replace(/\./g, "_");
            }
            if (!replaceNames[subPath]) {
              replaceNames[subPath] = subPath.replace(/\./g, "_");
            }
            parentAlias = replaceNames[path];
            pathAlias = replaceNames[subPath];
            if (relation.toMany && inversedRelation.toMany) {
              primaryRelation = _this._relationshipByPriority(relation, inversedRelation);
              inversedRelation = relation.inverseRelationship();
              middleTableName = _this._getMiddleTableNameForManyToManyRelation(primaryRelation);
              middleTableNameAlias = pathAlias + "__mid";
              if (primaryRelation === relation) {
                query.left_join(middleTableName, middleTableNameAlias, parentAlias + "._id = " + middleTableNameAlias + ".reflexive");
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, middleTableNameAlias + "." + relation.name + "_id = " + pathAlias + "._id");
              } else {
                query.left_join(middleTableName, middleTableNameAlias, parentAlias + "._id = " + middleTableNameAlias + "." + inversedRelation.name + "_id");
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, middleTableNameAlias + ".reflexive" + " = " + pathAlias + "._id");
              }
            } else {
              if (relation.toMany) {
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, pathAlias + "." + _.singularize(inversedRelation.name) + "_id" + " = " + parentAlias + "._id");
              } else {
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, pathAlias + '._id' + ' = ' + parentAlias + '.' + relation.name + '_id');
              }
            }
          }
          if (subkeys.length > 0) {
            return leftJoin(subkeys, relation.destinationEntity, subPath);
          }
        };
      })(this);
      replaceNames[this.tableAlias] = this.tableAlias;
      for (j = 0, len = joinMatches.length; j < len; j++) {
        match = joinMatches[j];
        match = match.slice(0, match.lastIndexOf("."));
        if (match !== this.tableAlias) {
          replaceNames[match] = match.replace(/\./g, "_");
          match = match.replace(this.tableAlias + ".", "");
          joins[match] = match;
        }
      }
      alreadyJoined = [];
      for (key in joins) {
        _subkeys = key.split(".");
        leftJoin(_subkeys, request.entity, this.tableAlias);
      }
      replaceNameSorted = Object.keys(replaceNames).sort().reverse();
      sqlString = query.toString();
      for (i in replaceNameSorted) {
        sqlString = sqlString.replace(new RegExp(replaceNameSorted[i].replace(".", "\\.") + "\\.(?![^\\s_]+\\\")", "g"), replaceNames[replaceNameSorted[i]] + ".");
        sqlString = sqlString.replace(new RegExp(replaceNameSorted[i].replace(".", "\\.") + this.quoteSymbol, "g"), replaceNames[replaceNameSorted[i]] + this.quoteSymbol);
      }
      return sqlString;
    };

    GenericSQLStore.prototype.processQuery = function(query, quoteSymbol) {
      var column, columnAfter, columnRegExp, j, len, match, matches, regString;
      if (quoteSymbol == null) {
        quoteSymbol = '`';
      }
      regString = query.replace(new RegExp('\'[^\']+\'', 'g'), '\'ignored\'');
      columnRegExp = new RegExp('SELF[\\w_]*(\\.[\\w_]+)+', 'gi');
      matches = regString.match(columnRegExp);
      for (j = 0, len = matches.length; j < len; j++) {
        match = matches[j];
        column = match.replace(/\./g, '\.');
        columnAfter = match.replace(/\.([^\.]+)$/g, '.' + quoteSymbol + '$1' + quoteSymbol);
        query = query.replace(new RegExp(column, 'g'), columnAfter);
      }
      return query;
    };

    GenericSQLStore.prototype._updateRelationsForObject = function(transaction, object, callback) {
      var addedObject, addedObjects, inversedRelationship, j, k, l, len, len1, len2, ref, ref1, ref2, reflexiveRelationship, relationship, removedObject, removedObjects, sql, sqls;
      sqls = [];
      ref = object.entity.relationships;
      for (j = 0, len = ref.length; j < len; j++) {
        relationship = ref[j];
        inversedRelationship = relationship.inverseRelationship();
        reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
        if (relationship.toMany && inversedRelationship.toMany && object._relationChanges && relationship === reflexiveRelationship) {
          addedObjects = (ref1 = object._relationChanges) != null ? ref1['added_' + relationship.name] : void 0;
          if (addedObjects) {
            for (k = 0, len1 = addedObjects.length; k < len1; k++) {
              addedObject = addedObjects[k];
              sql = 'INSERT INTO ' + this.quoteSymbol + this._getMiddleTableNameForManyToManyRelation(relationship) + this.quoteSymbol + ' (reflexive,' + this.quoteSymbol + relationship.name + '_id' + this.quoteSymbol + ') VALUES (' + this._recordIDForObjectID(object.objectID) + ',' + this._recordIDForObjectID(addedObject.objectID) + ')';
              sqls.push(sql);
            }
          }
          removedObjects = (ref2 = object._relationChanges) != null ? ref2['removed_' + relationship.name] : void 0;
          if (removedObjects) {
            for (l = 0, len2 = removedObjects.length; l < len2; l++) {
              removedObject = removedObjects[l];
              sql = 'DELETE FROM ' + this.quoteSymbol + this._getMiddleTableNameForManyToManyRelation(relationship) + this.quoteSymbol + ' WHERE reflexive = ' + this._recordIDForObjectID(object.objectID) + ' AND ' + this.quoteSymbol + relationship.name + '_id' + this.quoteSymbol + ' = ' + this._recordIDForObjectID(removedObject.objectID);
              sqls.push(sql);
            }
          }
        }
      }
      return async.forEachSeries(sqls, function(sql, cb) {
        return transaction.query(sql, cb);
      }, callback);
    };

    GenericSQLStore.prototype._getMiddleTableNameForManyToManyRelation = function(relationship) {
      var inversedRelationship, reflexiveRelationship;
      inversedRelationship = relationship.inverseRelationship();
      reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
      return this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name.toLowerCase();
    };

    GenericSQLStore.prototype._valuesWithRelationshipsForObject = function(object) {
      var attribute, data, id, j, key, len, ref, ref1, ref2, ref3, relation, value;
      data = {};
      ref = object._changes;
      for (key in ref) {
        value = ref[key];
        attribute = object.entity.getAttribute(key);
        data[key] = value;
      }
      ref1 = object.entity.relationships;
      for (j = 0, len = ref1.length; j < len; j++) {
        relation = ref1[j];
        if (!relation.toMany) {
          if (((ref2 = object._relationChanges) != null ? ref2[relation.name] : void 0) !== void 0) {
            if ((ref3 = object._relationChanges) != null ? ref3[relation.name] : void 0) {
              id = this._recordIDForObjectID(object._relationChanges[relation.name].objectID);
              data[relation.name + '_id'] = id;
            } else {
              data[relation.name + '_id'] = null;
            }
          }
        }
      }
      return data;
    };

    GenericSQLStore.prototype.permanentIDsForObjects = function(objects, callback) {
      var ids, j, len, object;
      ids = [];
      for (j = 0, len = objects.length; j < len; j++) {
        object = objects[j];
        ids.push(this._permanentIDForRecord(object.entity, this.permanentIDsCache[object.objectID.toString()]));
      }
      return ids;
    };

    GenericSQLStore.prototype.newObjectID = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/t' + referenceObject, entity);
    };

    GenericSQLStore.prototype._permanentIDForRecord = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/p' + referenceObject, entity);
    };

    GenericSQLStore.prototype._recordIDForObjectID = function(objectID) {
      return objectID.recordId();
    };

    GenericSQLStore.prototype._relationshipByPriority = function(relationship, inversedRelationship) {
      if (relationship.name > inversedRelationship.name) {
        return relationship;
      }
      return inversedRelationship;
    };

    GenericSQLStore.prototype._formatTableName = function(name) {
      return _.pluralize(name).toLowerCase();
    };

    GenericSQLStore.prototype.columnTypeForAttribute = function(attribute) {
      var type;
      type = null;
      switch (attribute.persistentType) {
        case 'bool':
        case 'boolean':
          type = 'tinyint(1)';
          break;
        case 'string':
        case 'email':
        case 'url':
          type = 'varchar(' + (attribute.info.length || 255) + ')';
          break;
        case 'text':
          if (attribute.info.length) {
            if (attribute.info.length < 256) {
              type = 'tinytext';
            } else if (attribute.info.length < 65536) {
              type = 'text';
            } else if (attribute.info.length < 16777216) {
              type = 'mediumtext';
            } else if (attribute.info.length < 4294967296) {
              type = 'longtext';
            }
          } else {
            type = 'longtext';
          }
          break;
        case 'data':
          if (attribute.info.length) {
            if (attribute.info.length < 256) {
              type = 'tinyblob';
            } else if (attribute.info.length < 65536) {
              type = 'blob';
            } else if (attribute.info.length < 16777216) {
              type = 'mediumblob';
            } else if (attribute.info.length < 4294967296) {
              type = 'longblob';
            }
          } else {
            type = 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          type = 'int(' + (attribute.info.length || 11) + ')';
          break;
        case 'decimal':
          type = 'decimal(' + (attribute.info.digits || 20) + ',' + (attribute.info.decimals || 5) + ')';
          break;
        case 'float':
          type = 'float';
          break;
        case 'double':
          type = 'double';
          break;
        case 'date':
          type = 'datetime';
          break;
        case 'timestamp':
          type = 'bigint(20)';
          break;
        case 'uuid':
          type = 'char(36)';
          break;
        case 'transformable':
          type = 'mediumtext';
          break;
        case 'enum':
          return 'varchar(' + (attribute.info.length || 30) + ')';
        default:
          return null;
      }
      return type;
    };

    GenericSQLStore.prototype._columnDefinitionForAttribute = function(attribute) {
      var definition, type;
      type = this.columnTypeForAttribute(attribute);
      if (!type) {
        return null;
      }
      definition = this.quoteSymbol + attribute.name + this.quoteSymbol + ' ' + type + ' DEFAULT NULL';
      if (attribute.info.unique) {
        definition += ' UNIQUE';
      }
      return definition;
    };

    GenericSQLStore.prototype.encodeValueForAttribute = function(value, attribute) {
      if (value === null) {
        return null;
      }
      switch (attribute.persistentType) {
        case 'datetime':
        case 'date':
          return moment(new Date(value)).format('YYYY-MM-DD HH:mm:ss');
      }
      return value;
    };

    GenericSQLStore.prototype.decodeValueForAttribute = function(value, attribute) {
      if (value === null) {
        return null;
      }
      switch (attribute.persistentType) {
        case 'datetime':
        case 'date':
          return new Date(value);
        case 'timestamp':
          return Number(value);
        case 'boolean':
          return !!value;
      }
      return value;
    };

    GenericSQLStore.prototype._indexesForEntity = function(entity) {
      var attribute, indexes, j, len, ref;
      indexes = _.clone(entity.indexes);
      ref = entity.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        attribute = ref[j];
        if (attribute.info.indexed) {
          indexes.push({
            name: attribute.name,
            columns: [attribute.name],
            type: 'key'
          });
        }
      }
      return indexes;
    };

    GenericSQLStore.prototype.syncSchema = function(options, callback) {
      var objectModel;
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      options = options || {};
      objectModel = this.storeCoordinator.objectModel;
      return this.getCurrentVersion((function(_this) {
        return function(err, currentVersion) {
          var error, migrations, queries;
          if (currentVersion === objectModel.version && !options.force) {
            return callback();
          } else if (!currentVersion && !options.ignoreVersion && !options.force) {
            return callback(new Error('current version not found, rerun syncSchema with enabled option ignoreVersion'));
          } else if ((currentVersion !== objectModel.version && options.ignoreVersion) || options.force) {
            try {
              queries = _this.createSchemaQueries(options);
            } catch (error) {
              err = error;
              return callback(err);
            }
            return _this._runRawQueriesInSingleTransaction(queries, callback);
          } else {
            migrations = objectModel.getMigrationsFrom(currentVersion);
            if (!migrations || migrations.length === 0) {
              throw new Error('migration ' + currentVersion + '=>' + objectModel.version + ' not found');
            }
            return async.forEachSeries(migrations, _this.runMigration.bind(_this), callback);
          }
        };
      })(this));
    };

    GenericSQLStore.prototype.runMigration = function(migration, callback) {
      var objectModel;
      objectModel = this.storeCoordinator.objectModel;
      return async.forEachSeries(migration.scriptsBefore, (function(_this) {
        return function(script, cb) {
          return _this._runMigrationScript(migration.modelFrom, script, cb);
        };
      })(this), (function(_this) {
        return function(err) {
          var error, queries;
          if (err) {
            return callback(err);
          }
          try {
            queries = _this.createMigrationQueries(migration);
            queries.push('UPDATE ' + _this.quoteSymbol + '_meta' + _this.quoteSymbol + ' SET ' + _this.quoteSymbol + 'value' + _this.quoteSymbol + ' = \'' + objectModel.version + '\' WHERE ' + _this.quoteSymbol + 'key' + _this.quoteSymbol + ' = \'version\'');
          } catch (error) {
            err = error;
            return callback(err);
          }
          return _this._runRawQueriesInSingleTransaction(queries, function(err) {
            if (err) {
              return callback(err);
            }
            return async.forEachSeries(migration.scriptsAfter, function(script, cb) {
              return _this._runMigrationScript(migration.modelTo, script, cb);
            }, callback);
          });
        };
      })(this));
    };

    GenericSQLStore.prototype._runMigrationScript = function(model, script, callback) {
      var context, persistentStoreCoordinator;
      persistentStoreCoordinator = new PersistentStoreCoordinator(model, this.storeCoordinator.globals);
      persistentStoreCoordinator.addStore(this);
      context = new ManagedObjectContext(persistentStoreCoordinator);
      return script(context, (function(_this) {
        return function(err) {
          if (err) {
            context.destroy();
            return callback(err);
          }
          return context.saveAndDestroy(callback);
        };
      })(this));
    };

    GenericSQLStore.prototype.getCurrentVersion = function(callback) {
      var query;
      query = squel.select().from('_meta').field('value').where(this.quoteSymbol + 'key' + this.quoteSymbol + ' = ?', 'version').limit(1);
      return this.connectionPool.query(query.toString(), function(err, rows) {
        var ref;
        if (err) {
          return callback(err);
        }
        return callback(null, (ref = rows[0]) != null ? ref.value : void 0);
      });
    };

    GenericSQLStore.prototype.createMigrationQueries = function(migration) {
      var attribute, change, e, entityFrom, entityName, entityTo, error, error1, inversedRelationship, j, k, l, len, len1, len2, len3, len4, m, modelFrom, modelTo, n, newColumnNames, oldAttribute, oldColumnNames, oldInversedRelationship, oldReflexiveRelationship, oldReflexiveTableName, oldRelationship, ref, ref1, ref2, ref3, ref4, ref5, ref6, reflexiveRelationship, reflexiveTableName, relationship, sqls, tableName, tmpTableName, updatedEntities;
      sqls = [];
      modelTo = migration.modelTo;
      modelFrom = migration.modelFrom;
      ref = migration.entitiesChanges;
      for (j = 0, len = ref.length; j < len; j++) {
        change = ref[j];
        entityName = change.entity;
        switch (change.change) {
          case '+':
            sqls = sqls.concat(this.createEntityQueries(modelTo.getEntity(entityName)));
            break;
          case '-':
            sqls.push('DROP TABLE IF EXISTS ' + this.quoteSymbol + this._formatTableName(entityName) + this.quoteSymbol);
            break;
          default:
            sqls.push('ALTER TABLE ' + this.quoteSymbol + this._formatTableName(entityName) + this.quoteSymbol + ' RENAME TO ' + this.quoteSymbol + this._formatTableName(change.change) + this.quoteSymbol);
        }
      }
      updatedEntities = _.uniq(Object.keys(migration.attributesChanges).concat(Object.keys(migration.relationshipsChanges)));
      for (k = 0, len1 = updatedEntities.length; k < len1; k++) {
        entityName = updatedEntities[k];
        entityTo = modelTo.getEntity(entityName);
        entityFrom = modelFrom.getEntity(entityName);
        oldColumnNames = ['_id'];
        newColumnNames = ['_id'];
        ref1 = entityTo.attributes;
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          attribute = ref1[l];
          change = (ref2 = migration.attributesChanges[entityName]) != null ? ref2[attribute.name] : void 0;
          if (change) {
            if (change !== '-' && change !== '+') {
              newColumnNames.push(attribute.name);
              oldColumnNames.push(change);
            }
          } else {
            try {
              oldAttribute = entityFrom.getAttribute(attribute.name);
              newColumnNames.push(attribute.name);
              oldColumnNames.push(oldAttribute.name);
            } catch (error) {
              e = error;
              console.error('attribute ' + attribute.name + ' not found in version ' + modelFrom.version);
            }
          }
        }
        ref3 = entityTo.relationships;
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          relationship = ref3[m];
          if (!relationship.toMany) {
            change = (ref4 = migration.relationshipsChanges[entityName]) != null ? ref4[relationship.name] : void 0;
            if (change) {
              if (change !== '-' && change !== '+') {
                newColumnNames.push(relationship.name + '_id');
                oldColumnNames.push(change + '_id');
              }
            } else {
              try {
                oldRelationship = entityFrom.getRelationship(relationship.name);
                newColumnNames.push(relationship.name + '_id');
                oldColumnNames.push(oldRelationship.name + '_id');
              } catch (error1) {
                e = error1;
                console.error('relationship ' + relationship.name + ' not found in version ' + modelFrom.version);
              }
            }
          }
        }
        tableName = this.quoteSymbol + this._formatTableName(entityName) + this.quoteSymbol;
        tmpTableName = this.quoteSymbol + this._formatTableName(entityName) + '_tmp' + this.quoteSymbol;
        sqls.push('DROP TABLE IF EXISTS ' + tmpTableName);
        sqls.push('ALTER TABLE ' + tableName + ' RENAME TO ' + tmpTableName);
        sqls = sqls.concat(this.createEntityQueries(entityTo, false, {
          ignoreRelationships: true
        }));
        sqls.push('INSERT INTO ' + tableName + ' (' + this.quoteSymbol + newColumnNames.join(this.quoteSymbol + ',' + this.quoteSymbol) + this.quoteSymbol + ') SELECT ' + this.quoteSymbol + oldColumnNames.join(this.quoteSymbol + ',' + this.quoteSymbol) + this.quoteSymbol + ' FROM ' + tmpTableName);
        sqls.push('DROP TABLE ' + tmpTableName);
      }
      ref5 = entityTo.relationships;
      for (n = 0, len4 = ref5.length; n < len4; n++) {
        relationship = ref5[n];
        inversedRelationship = relationship.inverseRelationship();
        if (relationship.toMany && inversedRelationship.toMany) {
          change = (ref6 = migration.relationshipsChanges[entityName]) != null ? ref6[relationship.name] : void 0;
          if (change) {
            if (change !== '+' && change !== '-') {
              oldRelationship = entityFrom.getRelationship(change);
              oldInversedRelationship = oldRelationship.inverseRelationship();
              oldReflexiveRelationship = this._relationshipByPriority(oldRelationship, oldInversedRelationship);
              reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
              oldReflexiveTableName = this.quoteSymbol + this._formatTableName(oldReflexiveRelationship.entity.name) + '_' + oldReflexiveRelationship.name + this.quoteSymbol;
              reflexiveTableName = this.quoteSymbol + this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name + this.quoteSymbol;
              sqls.push('DROP TABLE IF EXISTS ' + reflexiveTableName);
              sqls.push('ALTER TABLE ' + oldReflexiveTableName + ' RENAME TO ' + reflexiveTableName);
            }
          } else {
            sqls = sqls.concat(this.createEntityRelationshipQueries(entityTo));
          }
        }
      }
      return sqls;
    };

    GenericSQLStore.prototype._runRawQueriesInSingleTransaction = function(sqls, callback) {
      return this.connectionPool.createTransaction((function(_this) {
        return function(err, transaction) {
          if (err) {
            return callback(err);
          }
          return async.forEachSeries(sqls, function(sql, cb) {
            return transaction.query(sql, cb);
          }, function(err) {
            if (err) {
              return transaction.rollback(function() {
                if (callback) {
                  callback(err);
                }
                return _this.connectionPool.releaseTransaction(transaction);
              });
            } else {
              return transaction.commit(function() {
                callback();
                return _this.connectionPool.releaseTransaction(transaction);
              });
            }
          });
        };
      })(this));
    };

    return GenericSQLStore;

  })(IncrementalStore);

  module.exports = GenericSQLStore;

}).call(this);
