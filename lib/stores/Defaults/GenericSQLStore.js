// Generated by CoffeeScript 1.9.3
(function() {
  var GenericPool, IncrementalStore, ManagedObjectID, PersistentStoreRequest, Predicate, SQLiteStore, _, async, e, sqlite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  IncrementalStore = require('./../IncrementalStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  try {
    require('sqlite3');
  } catch (_error) {
    e = _error;
    throw new Error('sqlite3 module is required to user SQLite storage, please install it by running npm install --save sqlite3');
  }

  sqlite = require('sqlite3');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  SQLiteStore = (function(superClass) {
    extend(SQLiteStore, superClass);

    function SQLiteStore(storeCoordinator, URL) {
      this.storeCoordinator = storeCoordinator;
      this.URL = URL;
      this.connection = this.createConnection();
      this.fetchedObjectValuesCache = {};
      this.permanentIDsCache = {};
      this.debug = false;
    }

    SQLiteStore.prototype.createConnection = function() {
      throw new Error('createConnection must be overriden');
    };

    SQLiteStore.prototype.execute = function(request, context, callback, afterInsertCallback) {
      if (!(request instanceof PersistentStoreRequest)) {
        throw new Error('request ' + request + ' is not instance of PersistentStoreRequest');
      }
      if (request.type === 'save') {
        this.connection.createTransaction((function(_this) {
          return function(transaction) {
            transaction.debug = _this.debug;
            return async.series([
              function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var formattedTableName, sql;
                  formattedTableName = _this._formatTableName(insertedObject.entity.name);
                  sql = 'INSERT INTO ' + formattedTableName + ' (`_id`) VALUES (?)';
                  return transaction.sendQuery(sql, [null], function(err, result) {
                    if (err) {
                      return cb(err);
                    }
                    _this.permanentIDsCache[insertedObject.objectID.toString()] = result.insertId;
                    return cb();
                  });
                }, function(err) {
                  afterInsertCallback();
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(insertedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.sendQuery(sql, updateValues, function(err, result) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, insertedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, insertedObject, cb);
                  }
                }, seriesCallback);
              }, function(seriesCallback) {
                return async.forEach(request.updatedObjects, function(updatedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(updatedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.sendQuery(sql, updateValues, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, updatedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, updatedObject, cb);
                  }
                }, function(err) {
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.deletedObjects, function(deletedObject, cb) {
                  var formattedTableName, id, sql;
                  formattedTableName = _this._formatTableName(deletedObject.entity.name);
                  id = _this._recordIDForObjectID(deletedObject.objectID);
                  sql = 'DELETE FROM `' + formattedTableName + '` WHERE `_id` = ' + id;
                  return transaction.sendQuery(sql, function(err) {
                    return cb(err);
                  });
                }, function(err) {
                  return seriesCallback(err);
                });
              }
            ], function(err) {
              if (err) {
                return transaction.rollback(function(rollbackError) {
                  return callback(err);
                });
              }
              return transaction.commit(function(err) {
                _this.connection.releaseTransaction(transaction);
                return callback(err);
              });
            });
          };
        })(this));
      }
      if (request.type === 'fetch') {
        return this.connection.sendRawQuery(this.sqlForFetchRequest(request), (function(_this) {
          return function(err, rows) {
            var _row, attribute, i, ids, j, len, len1, objectID, ref, row;
            ids = [];
            if (err) {
              return callback(err);
            }
            for (i = 0, len = rows.length; i < len; i++) {
              row = rows[i];
              _row = {};
              ref = request.entity.attributes;
              for (j = 0, len1 = ref.length; j < len1; j++) {
                attribute = ref[j];
                _row[attribute.name] = row[attribute.name];
              }
              objectID = _this._permanentIDForRecord(request.entity, row._id);
              _this.fetchedObjectValuesCache[objectID.toString()] = _row;
              ids.push(objectID);
            }
            return callback(null, ids);
          };
        })(this));
      }
    };

    SQLiteStore.prototype.updateQueryForUpdatedObject = function(updatedObject) {
      var formattedTableName, id, key, updateValues, updates, value, values;
      formattedTableName = this._formatTableName(updatedObject.entity.name);
      id = this._recordIDForObjectID(updatedObject.objectID);
      values = this._valuesWithRelationshipsForObject(updatedObject);
      updates = [];
      updateValues = [];
      for (key in values) {
        value = values[key];
        updates.push('`' + key + '` = ?');
        updateValues.push(value);
      }
      if (updates.length > 0) {
        return ['UPDATE `' + formattedTableName + '` SET ' + updates.join(',') + ' WHERE `_id` = ' + id, updateValues];
      } else {
        return [null, null];
      }
    };

    SQLiteStore.prototype.sqlForFetchRequest = function(request) {
      var attribute, columns, descriptors, i, j, key, keys, len, len1, ref, sql;
      columns = ['`_id` as `_id`'];
      ref = request.entity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columns.push('`' + attribute.name + '` as `' + attribute.name + '`');
      }
      sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(request.entity.name) + '` SELF';
      if (request.predicate instanceof Predicate) {
        sql += ' WHERE ' + request.predicate.toString();
      } else if (request.predicate) {
        sql += ' WHERE ' + request.predicate;
      }
      if (Array.isArray(request.sortDescriptors) && request.sortDescriptors.length > 0) {
        descriptors = request.sortDescriptors;
        if (descriptors && !Array.isArray(descriptors)) {
          descriptors = [descriptors];
        }
        sql += ' ORDER BY ';
        keys = [];
        for (j = 0, len1 = descriptors.length; j < len1; j++) {
          key = descriptors[j];
          keys.push(key.toString());
        }
        sql += keys.join(',');
      }
      return sql;
    };

    SQLiteStore.prototype._updateRelationsForObject = function(transaction, object, callback) {
      var addedObject, addedObjects, i, inversedRelationship, j, k, len, len1, len2, ref, ref1, ref2, reflexiveRelationship, relationship, removedObject, removedObjects, sql, sqls;
      sqls = [];
      ref = object.entity.relationships;
      for (i = 0, len = ref.length; i < len; i++) {
        relationship = ref[i];
        inversedRelationship = relationship.inverseRelationship();
        reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
        if (relationship.toMany && inversedRelationship.toMany && object._relationChanges && relationship === reflexiveRelationship) {
          addedObjects = (ref1 = object._relationChanges) != null ? ref1['added_' + relationship.name] : void 0;
          if (addedObjects) {
            for (j = 0, len1 = addedObjects.length; j < len1; j++) {
              addedObject = addedObjects[j];
              sql = 'INSERT INTO `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` (reflexive,`' + relationship.name + '_id`) VALUES(' + this._recordIDForObjectID(object.objectID) + ',' + this._recordIDForObjectID(addedObject.objectID) + ')';
              sqls.push(sql);
            }
          }
          removedObjects = (ref2 = object._relationChanges) != null ? ref2['removed_' + relationship.name] : void 0;
          if (removedObjects) {
            for (k = 0, len2 = removedObjects.length; k < len2; k++) {
              removedObject = removedObjects[k];
              sql = 'DELETE FROM `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` WHERE reflexive = ' + this._recordIDForObjectID(object.objectID) + ' AND `' + relationship.name + '_id` = ' + this._recordIDForObjectID(removedObject.objectID);
              sqls.push(sql);
            }
          }
        }
      }
      return async.forEachSeries(sqls, function(sql, cb) {
        return transaction.sendQuery(sql, cb);
      }, callback);
    };

    SQLiteStore.prototype._valuesWithRelationshipsForObject = function(object) {
      var data, i, id, key, len, ref, ref1, ref2, ref3, relation, value;
      data = {};
      ref = object._changes;
      for (key in ref) {
        value = ref[key];
        data[key] = value;
      }
      ref1 = object.entity.relationships;
      for (i = 0, len = ref1.length; i < len; i++) {
        relation = ref1[i];
        if (!relation.toMany) {
          if (((ref2 = object._relationChanges) != null ? ref2[relation.name] : void 0) !== void 0) {
            if ((ref3 = object._relationChanges) != null ? ref3[relation.name] : void 0) {
              id = this._recordIDForObjectID(object._relationChanges[relation.name].objectID);
              data[relation.name + '_id'] = id;
            } else {
              data[relation.name + '_id'] = null;
            }
          }
        }
      }
      return data;
    };

    SQLiteStore.prototype.valuesForObject = function(ObjectID, context) {
      return this.fetchedObjectValuesCache[ObjectID.toString()] || {};
    };

    SQLiteStore.prototype.valuesForRelationship = function(relationship, ObjectID, context, callback) {
      var attribute, columns, i, inversedRelationship, len, mainRelationship, ref, sql;
      inversedRelationship = relationship.inverseRelationship();
      sql = null;
      columns = ['`_id` as _id'];
      ref = relationship.destinationEntity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columns.push('`' + attribute.name + '` as ' + attribute.name);
      }
      mainRelationship = this._relationshipByPriority(relationship, inversedRelationship);
      if (relationship.toMany && inversedRelationship.toMany) {
        if (mainRelationship === relationship) {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `' + relationship.name + '_id` FROM `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` WHERE `reflexive` = ' + this._recordIDForObjectID(ObjectID) + ')';
        } else {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `reflexive` FROM `' + this._formatTableName(inversedRelationship.entity.name) + '_' + inversedRelationship.name + '` WHERE `' + inversedRelationship.name + '_id` = ' + this._recordIDForObjectID(ObjectID) + ')';
        }
      } else {
        if (inversedRelationship.toMany) {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `' + relationship.name + '_id` FROM `' + this._formatTableName(relationship.entity.name) + '` WHERE `_id` = ' + this._recordIDForObjectID(ObjectID) + ') LIMIT 1';
        } else {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `' + inversedRelationship.name + '_id` = ' + this._recordIDForObjectID(ObjectID);
        }
      }
      return this.connection.sendRawQuery(sql, (function(_this) {
        return function(err, rows) {
          var _row, ids, j, k, len1, len2, objectID, ref1, row;
          ids = [];
          if (err) {
            return callback(err);
          }
          for (j = 0, len1 = rows.length; j < len1; j++) {
            row = rows[j];
            _row = {};
            ref1 = relationship.destinationEntity.attributes;
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              attribute = ref1[k];
              _row[attribute.name] = row[attribute.name];
            }
            objectID = _this._permanentIDForRecord(relationship.destinationEntity, row._id);
            _this.fetchedObjectValuesCache[objectID.toString()] = _row;
            ids.push(objectID);
          }
          if (relationship.toMany) {
            return callback(null, ids);
          } else {
            return callback(null, ids[0]);
          }
        };
      })(this));
    };

    SQLiteStore.prototype.permanentIDsForObjects = function(objects, callback) {
      var i, ids, len, object;
      ids = [];
      for (i = 0, len = objects.length; i < len; i++) {
        object = objects[i];
        ids.push(this._permanentIDForRecord(object.entity, this.permanentIDsCache[object.objectID.toString()]));
      }
      return ids;
    };

    SQLiteStore.prototype.newObjectID = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/t' + referenceObject, entity);
    };

    SQLiteStore.prototype._permanentIDForRecord = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/p' + referenceObject, entity);
    };

    SQLiteStore.prototype._recordIDForObjectID = function(objectID) {
      return objectID.recordId();
    };

    SQLiteStore.prototype.syncSchema = function(options, callback) {
      throw new Error('createConnection must be overriden');
    };

    SQLiteStore.prototype._relationshipByPriority = function(relationship, inversedRelationship) {
      if (relationship.name > inversedRelationship.name) {
        return relationship;
      }
      return inversedRelationship;
    };

    SQLiteStore.prototype._formatTableName = function(name) {
      return _.pluralize(name).toLowerCase();
    };

    SQLiteStore.prototype._columnDefinitionForAttribute = function(attribute) {
      var defaultValue, definition, type;
      type = null;
      defaultValue = attribute.info["default"] || 'NULL';
      switch (attribute.type) {
        case 'bool':
        case 'boolean':
          type = 'tinyint(1)';
          break;
        case 'string':
        case 'email':
        case 'url':
          type = 'varchar(' + (attribute.options.length || 255) + ')';
          break;
        case 'text':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinytext';
            } else if (attribute.options.length < 65536) {
              type = 'text';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumtext';
            } else if (attribute.options.length < 4294967296) {
              type = 'longtext';
            }
          } else {
            type = 'longtext';
          }
          break;
        case 'data':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinyblob';
            } else if (attribute.options.length < 65536) {
              type = 'blob';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumblob';
            } else if (attribute.options.length < 4294967296) {
              type = 'longblob';
            }
          } else {
            type = 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          type = 'int(' + (attribute.options.length || 11) + ')';
          break;
        case 'decimal':
          type = 'decimal(' + (attribute.options.digits || 20) + ',' + (attribute.options.decimals || 5) + ')';
          break;
        case 'float':
          type = 'float';
          break;
        case 'double':
          type = 'double';
          break;
        case 'date':
          type = 'datetime';
          break;
        case 'timestamp':
          type = 'bigint(20)';
          break;
        default:
          return null;
      }
      definition = '`' + attribute.name + '` ' + type + ' DEFAULT ' + defaultValue;
      if (attribute.info.unique) {
        definition += ' UNIQUE';
      }
      return definition;
    };

    return SQLiteStore;

  })(IncrementalStore);

  module.exports = SQLiteStore;

}).call(this);
