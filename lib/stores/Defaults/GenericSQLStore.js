// Generated by CoffeeScript 1.10.0
(function() {
  var AttributeTransformer, GenericPool, GenericSQLStore, IncrementalStore, ManagedObjectID, PersistentStoreRequest, Predicate, SortDescriptor, _, async, squel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  IncrementalStore = require('./../IncrementalStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  SortDescriptor = require('./../../FetchClasses/SortDescriptor');

  squel = require('squel');

  AttributeTransformer = require('../../Helpers/AttributeTransformer');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  GenericSQLStore = (function(superClass) {
    extend(GenericSQLStore, superClass);

    GenericSQLStore.prototype.tableAlias = 'SELF';

    function GenericSQLStore(storeCoordinator, URL, globals) {
      this.storeCoordinator = storeCoordinator;
      this.URL = URL;
      this.globals = globals;
      if (this.storeCoordinator) {
        this.connection = this.createConnection();
      }
      this.permanentIDsCache = {};
    }

    GenericSQLStore.prototype.createConnection = function() {
      throw new Error('createConnection must be overriden');
    };

    GenericSQLStore.prototype.execute = function(request, context, callback, afterInsertCallback) {
      if (!(request instanceof PersistentStoreRequest)) {
        throw new Error('request ' + request + ' is not instance of PersistentStoreRequest');
      }
      if (request.type === 'save') {
        this.connection.createTransaction((function(_this) {
          return function(transaction) {
            return async.series([
              function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var formattedTableName, sql;
                  formattedTableName = _this._formatTableName(insertedObject.entity.name);
                  sql = 'INSERT INTO ' + formattedTableName + ' (`_id`) VALUES (?)';
                  return transaction.sendQuery(sql, [null], function(err, result) {
                    if (err) {
                      return cb(err);
                    }
                    _this.permanentIDsCache[insertedObject.objectID.toString()] = result.insertId;
                    return cb();
                  });
                }, function(err) {
                  afterInsertCallback();
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(insertedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.sendQuery(sql, updateValues, function(err, result) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, insertedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, insertedObject, cb);
                  }
                }, seriesCallback);
              }, function(seriesCallback) {
                return async.forEach(request.updatedObjects, function(updatedObject, cb) {
                  var ref, sql, updateValues;
                  ref = _this.updateQueryForUpdatedObject(updatedObject), sql = ref[0], updateValues = ref[1];
                  if (sql) {
                    return transaction.sendQuery(sql, updateValues, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, updatedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, updatedObject, cb);
                  }
                }, function(err) {
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.deletedObjects, function(deletedObject, cb) {
                  var formattedTableName, id, sql;
                  formattedTableName = _this._formatTableName(deletedObject.entity.name);
                  id = _this._recordIDForObjectID(deletedObject.objectID);
                  sql = 'DELETE FROM `' + formattedTableName + '` WHERE `_id` = ' + id;
                  return transaction.sendQuery(sql, function(err) {
                    return cb(err);
                  });
                }, function(err) {
                  return seriesCallback(err);
                });
              }
            ], function(err) {
              if (err) {
                return transaction.rollback(function(rollbackError) {
                  _this.connection.releaseTransaction(transaction);
                  return callback(err);
                });
              }
              return transaction.commit(function(err) {
                _this.connection.releaseTransaction(transaction);
                return callback(err);
              });
            });
          };
        })(this));
      }
      if (request.type === 'fetch') {
        return this.connection.sendRawQuery(this.sqlForFetchRequest(request), (function(_this) {
          return function(err, rows) {
            var _row, attribute, columnName, ids, j, k, l, len, len1, len2, objectID, objectValues, ref, ref1, relationship, row;
            ids = [];
            if (err) {
              return callback(err);
            }
            objectValues = {};
            for (j = 0, len = rows.length; j < len; j++) {
              row = rows[j];
              _row = {};
              ref = request.entity.attributes;
              for (k = 0, len1 = ref.length; k < len1; k++) {
                attribute = ref[k];
                _row[attribute.name] = row[attribute.name];
              }
              ref1 = request.entity.relationships;
              for (l = 0, len2 = ref1.length; l < len2; l++) {
                relationship = ref1[l];
                if (!relationship.toMany) {
                  columnName = _.singularize(relationship.name) + '_id';
                  _row[columnName] = row[columnName];
                }
              }
              objectID = _this._permanentIDForRecord(request.entity, row._id);
              objectValues[objectID.toString()] = _row;
              ids.push(objectID);
            }
            return callback(null, ids, objectValues);
          };
        })(this));
      }
    };

    GenericSQLStore.prototype.numberOfObjectsForFetchRequest = function(request, callback) {
      return this.connection.sendRawQuery(this.countSqlForFetchRequest(request), (function(_this) {
        return function(err, result) {
          return callback(err, result[0].count);
        };
      })(this));
    };

    GenericSQLStore.prototype.updateQueryForUpdatedObject = function(updatedObject) {
      var formattedTableName, id, key, updateValues, updates, value, values;
      formattedTableName = this._formatTableName(updatedObject.entity.name);
      id = this._recordIDForObjectID(updatedObject.objectID);
      values = this._valuesWithRelationshipsForObject(updatedObject);
      updates = [];
      updateValues = [];
      for (key in values) {
        value = values[key];
        updates.push('`' + key + '` = ?');
        updateValues.push(value);
      }
      if (updates.length > 0) {
        return ['UPDATE `' + formattedTableName + '` SET ' + updates.join(',') + ' WHERE `_id` = ' + id, updateValues];
      } else {
        return [null, null];
      }
    };

    GenericSQLStore.prototype.countSqlForFetchRequest = function(request) {
      var query;
      query = squel.select().from(this._formatTableName(request.entity.name), this.tableAlias);
      query.field('COUNT(DISTINCT SELF._id)', 'count');
      if (request.predicate) {
        query.where(request.predicate.toString());
      }
      return this._getRawTranslatedQueryWithJoins(query, request);
    };

    GenericSQLStore.prototype.sqlForFetchRequest = function(request) {
      var attribute, column, columnName, descriptor, descriptors, j, k, l, len, len1, len2, query, ref, ref1, relationship;
      query = squel.select().from(this._formatTableName(request.entity.name), this.tableAlias);
      query.field(this.tableAlias + '._id', '_id');
      ref = request.entity.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        attribute = ref[j];
        query.field(this.tableAlias + '.' + attribute.name, attribute.name);
      }
      ref1 = request.entity.relationships;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        relationship = ref1[k];
        if (!relationship.toMany) {
          columnName = _.singularize(relationship.name) + '_id';
          query.field(this.tableAlias + '.' + columnName, columnName);
        }
      }
      if (request.predicate) {
        query.where(request.predicate.toString());
      }
      if (request.limit) {
        query.limit(request.limit);
      }
      if (request.offset) {
        query.offset(request.offset);
      }
      if (Array.isArray(request.sortDescriptors) && request.sortDescriptors.length > 0) {
        descriptors = request.sortDescriptors;
        for (l = 0, len2 = descriptors.length; l < len2; l++) {
          descriptor = descriptors[l];
          column = descriptor.attribute;
          if (column.indexOf(this.tableAlias + '.') !== 0) {
            column = this.tableAlias + '.' + column;
          }
          query.order(column, descriptor.ascending);
        }
      }
      query.group('SELF._id');
      return this._getRawTranslatedQueryWithJoins(query, request);
    };

    GenericSQLStore.prototype._getRawTranslatedQueryWithJoins = function(query, request) {
      var _subkeys, alreadyJoined, clearedSQLString, i, j, joinMatches, joins, key, leftJoin, len, match, replaceNameSorted, replaceNames, sqlString;
      replaceNames = {};
      joins = {};
      sqlString = query.toString();
      clearedSQLString = sqlString.replace(/\\"/g, '').replace(/"[^"]+"/g, '').replace(/\\'/g, '').replace(/'[^']+'/g, '');
      joinMatches = clearedSQLString.match(new RegExp(this.tableAlias + '(\\.[a-zA-Z_][a-zA-Z0-9_]*){2,}', 'g'));
      if (!joinMatches || joinMatches.length === 0) {
        return sqlString;
      }
      leftJoin = (function(_this) {
        return function(subkeys, parentEntity, path) {
          var as, inversedRelation, middleTableName, middleTableNameAlias, parentAlias, pathAlias, primaryRelation, relation, subPath;
          as = subkeys.shift();
          relation = parentEntity.relationshipByName(as);
          if (!relation) {
            throw new Error('relation ' + parentEntity.name + '=>' + as + ' not found');
          }
          inversedRelation = relation.inverseRelationship();
          subPath = path + "." + as;
          if (!~alreadyJoined.indexOf(subPath)) {
            alreadyJoined.push(subPath);
            if (!replaceNames[path]) {
              replaceNames[path] = path.replace(/\./g, "_");
            }
            if (!replaceNames[subPath]) {
              replaceNames[subPath] = subPath.replace(/\./g, "_");
            }
            parentAlias = replaceNames[path];
            pathAlias = replaceNames[subPath];
            if (relation.toMany && inversedRelation.toMany) {
              primaryRelation = _this._relationshipByPriority(relation, inversedRelation);
              inversedRelation = relation.inverseRelationship();
              middleTableName = _this._getMiddleTableNameForManyToManyRelation(primaryRelation);
              middleTableNameAlias = pathAlias + "__mid";
              if (primaryRelation === relation) {
                query.left_join(middleTableName, middleTableNameAlias, parentAlias + "._id = " + middleTableNameAlias + ".reflexive");
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, middleTableNameAlias + "." + relation.name + "_id = " + pathAlias + "._id");
              } else {
                query.left_join(middleTableName, middleTableNameAlias, parentAlias + "._id = " + middleTableNameAlias + "." + inversedRelation.name + "_id");
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, middleTableNameAlias + ".reflexive" + " = " + pathAlias + "._id");
              }
            } else {
              if (relation.toMany) {
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, pathAlias + "." + _.singularize(inversedRelation.name) + "_id" + " = " + parentAlias + "._id");
              } else {
                query.left_join(_this._formatTableName(relation.destinationEntity.name), pathAlias, pathAlias + '._id' + ' = ' + parentAlias + '.' + relation.name + '_id');
              }
            }
          }
          if (subkeys.length > 0) {
            return leftJoin(subkeys, relation.destinationEntity, subPath);
          }
        };
      })(this);
      replaceNames[this.tableAlias] = this.tableAlias;
      for (j = 0, len = joinMatches.length; j < len; j++) {
        match = joinMatches[j];
        match = match.slice(0, match.lastIndexOf("."));
        if (match !== this.tableAlias) {
          replaceNames[match] = match.replace(/\./g, "_");
          match = match.replace(this.tableAlias + ".", "");
          joins[match] = match;
        }
      }
      alreadyJoined = [];
      for (key in joins) {
        _subkeys = key.split(".");
        leftJoin(_subkeys, request.entity, this.tableAlias);
      }
      replaceNameSorted = Object.keys(replaceNames).sort().reverse();
      sqlString = query.toString();
      for (i in replaceNameSorted) {
        sqlString = sqlString.replace(new RegExp(replaceNameSorted[i].replace(".", "\\.") + "\\.(?![^\\s_]+\\\")", "g"), replaceNames[replaceNameSorted[i]] + ".");
        sqlString = sqlString.replace(new RegExp(replaceNameSorted[i].replace(".", "\\.") + "`", "g"), replaceNames[replaceNameSorted[i]] + "`");
      }
      return sqlString;
    };

    GenericSQLStore.prototype._updateRelationsForObject = function(transaction, object, callback) {
      var addedObject, addedObjects, inversedRelationship, j, k, l, len, len1, len2, ref, ref1, ref2, reflexiveRelationship, relationship, removedObject, removedObjects, sql, sqls;
      sqls = [];
      ref = object.entity.relationships;
      for (j = 0, len = ref.length; j < len; j++) {
        relationship = ref[j];
        inversedRelationship = relationship.inverseRelationship();
        reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
        if (relationship.toMany && inversedRelationship.toMany && object._relationChanges && relationship === reflexiveRelationship) {
          addedObjects = (ref1 = object._relationChanges) != null ? ref1['added_' + relationship.name] : void 0;
          if (addedObjects) {
            for (k = 0, len1 = addedObjects.length; k < len1; k++) {
              addedObject = addedObjects[k];
              sql = 'INSERT INTO `' + this._getMiddleTableNameForManyToManyRelation(relationship) + '` (reflexive,`' + relationship.name + '_id`) VALUES (' + this._recordIDForObjectID(object.objectID) + ',' + this._recordIDForObjectID(addedObject.objectID) + ')';
              sqls.push(sql);
            }
          }
          removedObjects = (ref2 = object._relationChanges) != null ? ref2['removed_' + relationship.name] : void 0;
          if (removedObjects) {
            for (l = 0, len2 = removedObjects.length; l < len2; l++) {
              removedObject = removedObjects[l];
              sql = 'DELETE FROM `' + this._getMiddleTableNameForManyToManyRelation(relationship) + '` WHERE reflexive = ' + this._recordIDForObjectID(object.objectID) + ' AND `' + relationship.name + '_id` = ' + this._recordIDForObjectID(removedObject.objectID);
              sqls.push(sql);
            }
          }
        }
      }
      return async.forEachSeries(sqls, function(sql, cb) {
        return transaction.sendQuery(sql, cb);
      }, callback);
    };

    GenericSQLStore.prototype._getMiddleTableNameForManyToManyRelation = function(relationship) {
      return this._formatTableName(relationship.entity.name) + '_' + relationship.name;
    };

    GenericSQLStore.prototype._valuesWithRelationshipsForObject = function(object) {
      var data, id, j, key, len, ref, ref1, ref2, ref3, relation, value;
      data = {};
      ref = object._changes;
      for (key in ref) {
        value = ref[key];
        data[key] = AttributeTransformer.persistentValueForAttribute(value, object.entity.attributesByName()[key]);
      }
      ref1 = object.entity.relationships;
      for (j = 0, len = ref1.length; j < len; j++) {
        relation = ref1[j];
        if (!relation.toMany) {
          if (((ref2 = object._relationChanges) != null ? ref2[relation.name] : void 0) !== void 0) {
            if ((ref3 = object._relationChanges) != null ? ref3[relation.name] : void 0) {
              id = this._recordIDForObjectID(object._relationChanges[relation.name].objectID);
              data[relation.name + '_id'] = id;
            } else {
              data[relation.name + '_id'] = null;
            }
          }
        }
      }
      return data;
    };

    GenericSQLStore.prototype.permanentIDsForObjects = function(objects, callback) {
      var ids, j, len, object;
      ids = [];
      for (j = 0, len = objects.length; j < len; j++) {
        object = objects[j];
        ids.push(this._permanentIDForRecord(object.entity, this.permanentIDsCache[object.objectID.toString()]));
      }
      return ids;
    };

    GenericSQLStore.prototype.newObjectID = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/t' + referenceObject, entity);
    };

    GenericSQLStore.prototype._permanentIDForRecord = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/p' + referenceObject, entity);
    };

    GenericSQLStore.prototype._recordIDForObjectID = function(objectID) {
      return objectID.recordId();
    };

    GenericSQLStore.prototype.syncSchema = function(options, callback) {
      throw new Error('createConnection must be overriden');
    };

    GenericSQLStore.prototype._relationshipByPriority = function(relationship, inversedRelationship) {
      if (relationship.name > inversedRelationship.name) {
        return relationship;
      }
      return inversedRelationship;
    };

    GenericSQLStore.prototype._formatTableName = function(name) {
      return _.pluralize(name).toLowerCase();
    };

    GenericSQLStore.prototype._columnDefinitionForAttribute = function(attribute) {
      var definition, type;
      type = null;
      switch (attribute.type) {
        case 'bool':
        case 'boolean':
          type = 'tinyint(1)';
          break;
        case 'string':
        case 'email':
        case 'url':
          type = 'varchar(' + (attribute.options.length || 255) + ')';
          break;
        case 'text':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinytext';
            } else if (attribute.options.length < 65536) {
              type = 'text';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumtext';
            } else if (attribute.options.length < 4294967296) {
              type = 'longtext';
            }
          } else {
            type = 'longtext';
          }
          break;
        case 'data':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinyblob';
            } else if (attribute.options.length < 65536) {
              type = 'blob';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumblob';
            } else if (attribute.options.length < 4294967296) {
              type = 'longblob';
            }
          } else {
            type = 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          type = 'int(' + (attribute.options.length || 11) + ')';
          break;
        case 'decimal':
          type = 'decimal(' + (attribute.options.digits || 20) + ',' + (attribute.options.decimals || 5) + ')';
          break;
        case 'float':
          type = 'float';
          break;
        case 'double':
          type = 'double';
          break;
        case 'date':
          type = 'datetime';
          break;
        case 'timestamp':
          type = 'bigint(20)';
          break;
        case 'uuid':
          type = 'char(36)';
          break;
        case 'transformable':
          type = 'mediumtext';
          break;
        default:
          return null;
      }
      definition = '`' + attribute.name + '` ' + type + ' DEFAULT NULL';
      if (attribute.info.unique) {
        definition += ' UNIQUE';
      }
      return definition;
    };

    return GenericSQLStore;

  })(IncrementalStore);

  module.exports = GenericSQLStore;

}).call(this);
