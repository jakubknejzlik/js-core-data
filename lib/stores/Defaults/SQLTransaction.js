// Generated by CoffeeScript 1.10.0
(function() {
  var SQLTransaction;

  SQLTransaction = (function() {
    function SQLTransaction(connection, store) {
      this.connection = connection;
      this.store = store;
      this.started = false;
      this.autoRollback = true;
      this.committed = false;
      this.rollbacked = false;
    }

    SQLTransaction.prototype.ensureBegin = function(callback) {
      if (this.started) {
        return callback();
      }
      this.started = true;
      return this.connection.query('BEGIN', function(err) {
        return callback(err);
      });
    };

    SQLTransaction.prototype.query = function(query, params, callback) {
      if (this.committed) {
        return callback(new Error('cannot send query to commited transaction'));
      }
      if (this.rollbacked) {
        return callback(new Error('cannot send query to rolled back transaction'));
      }
      if (typeof params === 'function') {
        callback = params;
        params = void 0;
      }
      callback = this._wrapCallbackForAutoRollback(callback);
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      return this.ensureBegin((function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this.connection.query(query, params, callback);
        };
      })(this));
    };

    SQLTransaction.prototype.commit = function(callback) {
      if (!this.started) {
        this.committed = true;
        return callback();
      }
      if (this.committed) {
        return callback(new Error('cannot commit already commited transaction'));
      }
      if (this.rollbacked) {
        return callback(new Error('cannot commit transaction after rollback'));
      }
      this.committed = true;
      return this.connection.query('COMMIT', callback);
    };

    SQLTransaction.prototype.rollback = function(callback) {
      if (!this.started) {
        return callback(new Error('cannot rollback transaction before begin'));
      }
      if (this.committed) {
        return callback(new Error('cannot rollback transaction after commit'));
      }
      if (this.rollbacked) {
        return callback(new Error('cannot rollback already rolled back transaction'));
      }
      this.rollbacked = true;
      return this.connection.query('ROLLBACK', callback);
    };

    SQLTransaction.prototype._wrapCallbackForAutoRollback = function(callback) {
      var _callback;
      _callback = callback;
      if (this.autoRollback) {
        _callback = (function(_this) {
          return function(err, results) {
            if (err) {
              return _this.rollback(function() {
                if (callback) {
                  return callback(err);
                }
              });
            } else {
              if (callback) {
                return callback(err, results);
              }
            }
          };
        })(this);
      }
      return _callback;
    };

    SQLTransaction.prototype.createRow = function(tableName, callback) {
      callback = this._wrapCallbackForAutoRollback(callback);
      return this.ensureBegin((function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this.connection.createRow(tableName, callback);
        };
      })(this));
    };

    return SQLTransaction;

  })();

  module.exports = SQLTransaction;

}).call(this);
