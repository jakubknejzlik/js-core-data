// Generated by CoffeeScript 1.9.3
(function() {
  var GenericPool, GenericSQLStore, ManagedObjectID, MySQLConnection, MySQLStore, PersistentStoreRequest, Predicate, Transaction, _, async, e, mysql,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GenericSQLStore = require('./GenericSQLStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  try {
    require('mysql');
  } catch (_error) {
    e = _error;
    throw new Error('mysql module is required to user MySQL storage, please install it by running npm install --save mysql');
  }

  mysql = require('mysql');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLStore = (function(superClass) {
    extend(MySQLStore, superClass);

    function MySQLStore() {
      return MySQLStore.__super__.constructor.apply(this, arguments);
    }

    MySQLStore.prototype.quoteSymbol = '`';

    MySQLStore.prototype.createConnection = function() {
      return new MySQLConnection(this.URL, this);
    };

    MySQLStore.prototype.createSchemaQueries = function(options) {
      var entity, key, objectModel, ref, sqls;
      if (options == null) {
        options = {};
      }
      objectModel = this.storeCoordinator.objectModel;
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        sqls = sqls.concat(this.createEntityQueries(entity, options.force));
      }
      sqls.push('CREATE TABLE IF NOT EXISTS `_meta` (`key` varchar(10) NOT NULL,`value` varchar(250) NOT NULL,PRIMARY KEY (`key`)) ENGINE=InnoDB  DEFAULT CHARSET=utf8');
      sqls.push('INSERT INTO `_meta` VALUES(\'version\',\'' + objectModel.version + '\') ON DUPLICATE KEY UPDATE `value` = VALUES(`value`)');
      return sqls;
    };

    MySQLStore.prototype.createEntityQueries = function(entity, force, options) {
      var attribute, columnDefinition, i, index, j, k, len, len1, len2, parts, ref, ref1, ref2, relationship, sql, sqls, tableName;
      if (options == null) {
        options = {};
      }
      sqls = [];
      tableName = this._formatTableName(entity.name);
      parts = ['`_id` int(11) NOT NULL AUTO_INCREMENT', 'PRIMARY KEY (`_id`)'];
      ref = entity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columnDefinition = this._columnDefinitionForAttribute(attribute);
        if (columnDefinition) {
          parts.push(columnDefinition);
        } else {
          throw new Error('unknown attribute type ' + attribute.type);
        }
      }
      ref1 = this._indexesForEntity(entity);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        index = ref1[j];
        parts.push('KEY `' + index.name + '` (`' + index.columns.join('`,`') + '`)');
      }
      ref2 = entity.relationships;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        relationship = ref2[k];
        if (!relationship.toMany) {
          parts.push('`' + relationship.name + '_id` int(11) DEFAULT NULL');
        }
      }
      if (force) {
        sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
      }
      sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
      sql += parts.join(',');
      sql += ') ENGINE=InnoDB  DEFAULT CHARSET=utf8;';
      sqls.push(sql);
      if (!options.ignoreRelationships) {
        sqls = sqls.concat(this.createEntityRelationshipQueries(entity, force));
      }
      return sqls;
    };

    MySQLStore.prototype.createEntityRelationshipQueries = function(entity, force) {
      var inversedRelationship, key, ref, reflexiveRelationship, reflexiveTableName, relationship, sqls;
      sqls = [];
      ref = entity.relationships;
      for (key in ref) {
        relationship = ref[key];
        if (relationship.toMany) {
          inversedRelationship = relationship.inverseRelationship();
          if (inversedRelationship.toMany) {
            reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
            reflexiveTableName = this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name;
            if (force) {
              sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
            }
            sqls.push('CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))');
          }
        }
      }
      return sqls;
    };

    return MySQLStore;

  })(GenericSQLStore);

  MySQLConnection = (function(superClass) {
    extend(MySQLConnection, superClass);

    function MySQLConnection(url, store, settings) {
      var ref, ref1;
      this.store = store;
      this.sendRawQuery = bind(this.sendRawQuery, this);
      this.pool = GenericPool.Pool({
        name: "mysql",
        create: function(callback) {
          var connection;
          connection = mysql.createConnection(url, {
            multipleStatements: true
          });
          return connection.connect(function(err) {
            return callback(err, connection);
          });
        },
        destroy: function(connection) {
          return connection.destroy();
        },
        max: (settings != null ? settings.maxConnections : void 0) || (process.NODE_ENV === 'production' ? 100 : 10),
        idleTimeoutMillis: (ref = settings != null ? settings.idletimeoutMillis : void 0) != null ? ref : 60 * 1000,
        reapIntervalMillis: (ref1 = settings != null ? settings.reapIntervalMillis : void 0) != null ? ref1 : 5 * 1000
      });
    }

    MySQLConnection.prototype.sendRawQuery = function(query, params, callback) {
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      return this.pool.acquire((function(_this) {
        return function(err, conn) {
          var error, q, ref, ref1;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          try {
            q = conn.query(query, params, function(err, result, fields) {
              _this.pool.release(conn);
              return typeof callback === "function" ? callback(err, result, fields) : void 0;
            });
            if ((ref = _this.store.globals) != null ? ref.logging : void 0) {
              return (ref1 = _this.store.globals) != null ? ref1.logging(q.sql) : void 0;
            }
          } catch (_error) {
            error = _error;
            _this.pool.release(conn);
            return typeof callback === "function" ? callback(error) : void 0;
          }
        };
      })(this));
    };

    MySQLConnection.prototype.sendQuery = function(query, params, callback) {
      var err, sql;
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      try {
        sql = query.getSQL();
        return this.sendRawQuery(sql, params, callback);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    MySQLConnection.prototype.createTransaction = function(callback) {
      return this.pool.acquire((function(_this) {
        return function(err, connection) {
          if (err) {
            return callback(err);
          }
          return callback(new Transaction(connection, _this.store));
        };
      })(this));
    };

    MySQLConnection.prototype.releaseTransaction = function(transaction) {
      return this.pool.release(transaction.connection);
    };

    return MySQLConnection;

  })(Object);

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    function Transaction(connection1, store) {
      this.connection = connection1;
      this.store = store;
      this.started = false;
      this.autoRollback = true;
    }

    Transaction.prototype.ensureBegin = function(callback) {
      var ref, ref1;
      if (this.started) {
        return callback();
      }
      this.started = true;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('BEGIN');
      }
      return this.connection.query('BEGIN', function(err) {
        return callback(err);
      });
    };

    Transaction.prototype.sendQuery = function(query, params, callback) {
      var q;
      if (typeof params === 'function') {
        callback = params;
        params = void 0;
      }
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      q = typeof query === 'string' ? query : query.getSQL();
      return this.ensureBegin((function(_this) {
        return function(err) {
          var ref, ref1;
          if (err) {
            if (self.autoRollback) {
              return _this.rollback(function() {
                return callback(err);
              });
            } else {
              return callback(err);
            }
          }
          query = _this.connection.query(q, params, callback);
          if ((ref = _this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
            return _this.store.globals.logging(query.sql);
          }
        };
      })(this));
    };

    Transaction.prototype.commit = function(callback) {
      var ref, ref1;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('COMMIT');
      }
      return this.connection.query('COMMIT', callback);
    };

    Transaction.prototype.rollback = function(callback) {
      var ref, ref1;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('ROLLBACK');
      }
      return this.connection.query('ROLLBACK', callback);
    };

    return Transaction;

  })(Object);

  module.exports = MySQLStore;

}).call(this);
