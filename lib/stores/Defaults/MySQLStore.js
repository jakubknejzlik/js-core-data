// Generated by CoffeeScript 1.10.0
(function() {
  var GenericPool, GenericSQLStore, ManagedObjectID, MySQLConnection, MySQLStore, PersistentStoreRequest, Predicate, Transaction, _, async, e, error1, mysql,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GenericSQLStore = require('./GenericSQLStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  try {
    require('mysql');
  } catch (error1) {
    e = error1;
    throw new Error('mysql module is required to user MySQL storage, please install it by running npm install --save mysql');
  }

  mysql = require('mysql');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLStore = (function(superClass) {
    extend(MySQLStore, superClass);

    function MySQLStore() {
      return MySQLStore.__super__.constructor.apply(this, arguments);
    }

    MySQLStore.prototype.createConnection = function() {
      return new MySQLConnection(this.URL, this);
    };

    MySQLStore.prototype.syncSchema = function(options, callback) {
      var attribute, columnDefinition, entity, i, inversedRelationship, j, key, len, len1, objectModel, parts, ref, ref1, ref2, ref3, reflexiveRelationship, reflexiveTableName, relationship, schema, sql, sqls, tableName;
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      options = options || {};
      objectModel = this.storeCoordinator.objectModel;
      schema = {};
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        tableName = this._formatTableName(entity.name);
        parts = ['`_id` int(11) NOT NULL AUTO_INCREMENT', 'PRIMARY KEY (`_id`)'];
        ref1 = entity.attributes;
        for (i = 0, len = ref1.length; i < len; i++) {
          attribute = ref1[i];
          columnDefinition = this._columnDefinitionForAttribute(attribute);
          if (columnDefinition) {
            parts.push(columnDefinition);
          } else {
            return callback(new Error('unknown attribute type ' + attribute.type));
          }
        }
        ref2 = entity.relationships;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          relationship = ref2[j];
          if (!relationship.toMany) {
            parts.push('`' + relationship.name + '_id` int(11) DEFAULT NULL');
          }
        }
        if (options.force) {
          sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
        }
        sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
        sql += parts.join(',');
        sql += ') ENGINE=InnoDB  DEFAULT CHARSET=utf8;';
        schema[tableName] = sql;
        ref3 = entity.relationships;
        for (key in ref3) {
          relationship = ref3[key];
          if (relationship.toMany) {
            inversedRelationship = relationship.inverseRelationship();
            if (inversedRelationship.toMany) {
              reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
              reflexiveTableName = this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name;
              if (options.force) {
                sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
              }
              schema[reflexiveTableName] = 'CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))';
            }
          }
        }
      }
      for (key in schema) {
        sql = schema[key];
        sqls.push(sql);
      }
      return async.forEachSeries(sqls, (function(_this) {
        return function(sql, cb) {
          return _this.connection.sendRawQuery(sql, cb);
        };
      })(this), function(err) {
        if (callback) {
          return callback(err);
        }
      });
    };

    return MySQLStore;

  })(GenericSQLStore);

  MySQLConnection = (function(superClass) {
    extend(MySQLConnection, superClass);

    function MySQLConnection(url, store, settings) {
      var ref, ref1;
      this.store = store;
      this.sendRawQuery = bind(this.sendRawQuery, this);
      this.pool = GenericPool.Pool({
        name: "mysql",
        create: function(callback) {
          var connection;
          connection = mysql.createConnection(url, {
            multipleStatements: true
          });
          return connection.connect(function(err) {
            return callback(err, connection);
          });
        },
        destroy: function(connection) {
          return connection.destroy();
        },
        max: (settings != null ? settings.maxConnections : void 0) || (process.NODE_ENV === 'production' ? 100 : 10),
        idleTimeoutMillis: (ref = settings != null ? settings.idletimeoutMillis : void 0) != null ? ref : 60 * 1000,
        reapIntervalMillis: (ref1 = settings != null ? settings.reapIntervalMillis : void 0) != null ? ref1 : 5 * 1000
      });
    }

    MySQLConnection.prototype.sendRawQuery = function(query, params, callback) {
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      return this.pool.acquire((function(_this) {
        return function(err, conn) {
          var error, error2, q, ref, ref1;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          try {
            q = conn.query(query, params, function(err, result, fields) {
              _this.pool.release(conn);
              return typeof callback === "function" ? callback(err, result, fields) : void 0;
            });
            if ((ref = _this.store.globals) != null ? ref.logging : void 0) {
              return (ref1 = _this.store.globals) != null ? ref1.logging(q.sql) : void 0;
            }
          } catch (error2) {
            error = error2;
            _this.pool.release(conn);
            return typeof callback === "function" ? callback(error) : void 0;
          }
        };
      })(this));
    };

    MySQLConnection.prototype.sendQuery = function(query, params, callback) {
      var err, error2, sql;
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      try {
        sql = query.getSQL();
        return this.sendRawQuery(sql, params, callback);
      } catch (error2) {
        err = error2;
        return callback(err);
      }
    };

    MySQLConnection.prototype.createTransaction = function(callback) {
      return this.pool.acquire((function(_this) {
        return function(err, connection) {
          if (err) {
            return callback(err);
          }
          return callback(new Transaction(connection, _this.store));
        };
      })(this));
    };

    MySQLConnection.prototype.releaseTransaction = function(transaction) {
      return this.pool.release(transaction.connection);
    };

    return MySQLConnection;

  })(Object);

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    function Transaction(connection1, store) {
      this.connection = connection1;
      this.store = store;
      this.started = false;
      this.autoRollback = true;
    }

    Transaction.prototype.ensureBegin = function(callback) {
      var ref, ref1;
      if (this.started) {
        return callback();
      }
      this.started = true;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('BEGIN');
      }
      return this.connection.query('BEGIN', function(err) {
        return callback(err);
      });
    };

    Transaction.prototype.sendQuery = function(query, params, callback) {
      var q;
      if (typeof params === 'function') {
        callback = params;
        params = void 0;
      }
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      q = typeof query === 'string' ? query : query.getSQL();
      return this.ensureBegin((function(_this) {
        return function(err) {
          var ref, ref1;
          if (err) {
            if (self.autoRollback) {
              return _this.rollback(function() {
                return callback(err);
              });
            } else {
              return callback(err);
            }
          }
          query = _this.connection.query(q, params, callback);
          if ((ref = _this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
            return _this.store.globals.logging(query.sql);
          }
        };
      })(this));
    };

    Transaction.prototype.commit = function(callback) {
      var ref, ref1;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('COMMIT');
      }
      return this.connection.query('COMMIT', callback);
    };

    Transaction.prototype.rollback = function(callback) {
      var ref, ref1;
      if ((ref = this.store) != null ? (ref1 = ref.globals) != null ? ref1.logging : void 0 : void 0) {
        this.store.globals.logging('ROLLBACK');
      }
      return this.connection.query('ROLLBACK', callback);
    };

    return Transaction;

  })(Object);

  module.exports = MySQLStore;

}).call(this);
