// Generated by CoffeeScript 1.9.3
(function() {
  var GenericPool, IncrementalStore, ManagedObjectID, MySQLConnection, MySQLStore, PersistentStoreRequest, Predicate, Transaction, _, async, mysql,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  IncrementalStore = require('./../IncrementalStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  mysql = require('mysql');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLStore = (function(superClass) {
    extend(MySQLStore, superClass);

    function MySQLStore(storeCoordinator, URL) {
      this.storeCoordinator = storeCoordinator;
      this.URL = URL;
      this.connection = new MySQLConnection(this.URL, this);
      this.fetchedObjectValuesCache = {};
      this.permanentIDsCache = {};
      this.debug = false;
    }

    MySQLStore.prototype.execute = function(request, context, callback, afterInsertCallback) {
      if (!(request instanceof PersistentStoreRequest)) {
        throw new Error('request ' + request + ' is not instance of PersistentStoreRequest');
      }
      if (request.type === 'save') {
        this.connection.createTransaction((function(_this) {
          return function(transaction) {
            transaction.debug = _this.debug;
            return async.series([
              function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var formattedTableName, inserts, sql;
                  formattedTableName = _this._formatTableName(insertedObject.entity.name);
                  inserts = ['`_id` = NULL'];
                  sql = 'INSERT INTO ' + formattedTableName + ' SET ' + inserts.join(',');
                  return transaction.sendQuery(sql, function(err, result) {
                    if (err) {
                      return cb(err);
                    }
                    _this.permanentIDsCache[insertedObject.objectID.toString()] = result.insertId;
                    return cb();
                  });
                }, function(err) {
                  afterInsertCallback();
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.insertedObjects, function(insertedObject, cb) {
                  var formattedTableName, id, key, sql, updates, value, values;
                  formattedTableName = _this._formatTableName(insertedObject.entity.name);
                  values = _this._valuesWithRelationshipsForObject(insertedObject);
                  id = _this._recordIDForObjectID(insertedObject.objectID);
                  updates = [];
                  for (key in values) {
                    value = values[key];
                    updates.push('`' + key + '` = ' + mysql.escape(value));
                  }
                  if (updates.length > 0) {
                    sql = 'UPDATE `' + formattedTableName + '` SET ' + updates.join(',') + ' WHERE `_id` = ' + mysql.escape(id);
                    return transaction.sendQuery(sql, function(err, result) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, insertedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, insertedObject, cb);
                  }
                }, seriesCallback);
              }, function(seriesCallback) {
                return async.forEach(request.updatedObjects, function(updatedObject, cb) {
                  var formattedTableName, id, key, sql, updates, value, values;
                  formattedTableName = _this._formatTableName(updatedObject.entity.name);
                  id = _this._recordIDForObjectID(updatedObject.objectID);
                  values = _this._valuesWithRelationshipsForObject(updatedObject);
                  updates = [];
                  for (key in values) {
                    value = values[key];
                    updates.push('`' + key + '` = ' + mysql.escape(value));
                  }
                  if (updates.length > 0) {
                    sql = 'UPDATE `' + formattedTableName + '` SET ' + updates.join(',') + ' WHERE `_id` = ' + mysql.escape(id);
                    return transaction.sendQuery(sql, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      return _this._updateRelationsForObject(transaction, updatedObject, cb);
                    });
                  } else {
                    return _this._updateRelationsForObject(transaction, updatedObject, cb);
                  }
                }, function(err) {
                  return seriesCallback(err);
                });
              }, function(seriesCallback) {
                return async.forEach(request.deletedObjects, function(deletedObject, cb) {
                  var formattedTableName, id, sql;
                  formattedTableName = _this._formatTableName(deletedObject.entity.name);
                  id = _this._recordIDForObjectID(deletedObject.objectID);
                  sql = 'DELETE FROM `' + formattedTableName + '` WHERE `_id` = ' + mysql.escape(id);
                  return transaction.sendQuery(sql, function(err) {
                    return cb(err);
                  });
                }, function(err) {
                  return seriesCallback(err);
                });
              }
            ], function(err) {
              if (err) {
                return transaction.rollback(function(rollbackError) {
                  return callback(err);
                });
              }
              return transaction.commit(function(err) {
                _this.connection.releaseTransaction(transaction);
                return callback(err);
              });
            });
          };
        })(this));
      }
      if (request.type === 'fetch') {
        return this.connection.sendRawQuery(this._sqlForFetchRequest(request), (function(_this) {
          return function(err, rows) {
            var _row, attribute, i, ids, j, len, len1, objectID, ref, row;
            ids = [];
            if (err) {
              return callback(err);
            }
            for (i = 0, len = rows.length; i < len; i++) {
              row = rows[i];
              _row = {};
              ref = request.entity.attributes;
              for (j = 0, len1 = ref.length; j < len1; j++) {
                attribute = ref[j];
                _row[attribute.name] = row[attribute.name];
              }
              objectID = _this._permanentIDForRecord(request.entity, row._id);
              _this.fetchedObjectValuesCache[objectID.toString()] = _row;
              ids.push(objectID);
            }
            return callback(null, ids);
          };
        })(this));
      }
    };

    MySQLStore.prototype._sqlForFetchRequest = function(request) {
      var attribute, columns, descriptors, i, j, key, keys, len, len1, ref, sql;
      columns = ['`_id` as `_id`'];
      ref = request.entity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columns.push('`' + attribute.name + '` as `' + attribute.name + '`');
      }
      sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(request.entity.name) + '` SELF';
      if (request.predicate instanceof Predicate) {
        sql += ' WHERE ' + request.predicate.toString();
      } else if (request.predicate) {
        sql += ' WHERE ' + request.predicate;
      }
      if (Array.isArray(request.sortDescriptors) && request.sortDescriptors.length > 0) {
        descriptors = request.sortDescriptors;
        if (descriptors && !Array.isArray(descriptors)) {
          descriptors = [descriptors];
        }
        sql += ' ORDER BY ';
        keys = [];
        for (j = 0, len1 = descriptors.length; j < len1; j++) {
          key = descriptors[j];
          keys.push(key.toString());
        }
        sql += keys.join(',');
      }
      return sql;
    };

    MySQLStore.prototype._updateRelationsForObject = function(transaction, object, callback) {
      var addedObject, addedObjects, i, inversedRelationship, j, k, len, len1, len2, ref, ref1, ref2, reflexiveRelationship, relationship, removedObject, removedObjects, sql, sqls;
      sqls = [];
      ref = object.entity.relationships;
      for (i = 0, len = ref.length; i < len; i++) {
        relationship = ref[i];
        inversedRelationship = relationship.inverseRelationship();
        reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
        if (relationship.toMany && inversedRelationship.toMany && object._relationChanges && relationship === reflexiveRelationship) {
          addedObjects = (ref1 = object._relationChanges) != null ? ref1['added_' + relationship.name] : void 0;
          if (addedObjects) {
            for (j = 0, len1 = addedObjects.length; j < len1; j++) {
              addedObject = addedObjects[j];
              sql = 'INSERT INTO `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` SET reflexive = ' + mysql.escape(this._recordIDForObjectID(object.objectID)) + ',`' + relationship.name + '_id` = ' + mysql.escape(this._recordIDForObjectID(addedObject.objectID));
              sqls.push(sql);
            }
          }
          removedObjects = (ref2 = object._relationChanges) != null ? ref2['removed_' + relationship.name] : void 0;
          if (removedObjects) {
            for (k = 0, len2 = removedObjects.length; k < len2; k++) {
              removedObject = removedObjects[k];
              sql = 'DELETE FROM `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` WHERE reflexive = ' + mysql.escape(this._recordIDForObjectID(object.objectID)) + ' AND `' + relationship.name + '_id` = ' + mysql.escape(this._recordIDForObjectID(removedObject.objectID));
              sqls.push(sql);
            }
          }
        }
      }
      return async.forEachSeries(sqls, function(sql, cb) {
        return transaction.sendQuery(sql, cb);
      }, callback);
    };

    MySQLStore.prototype._valuesWithRelationshipsForObject = function(object) {
      var data, i, id, key, len, ref, ref1, ref2, ref3, relation, value;
      data = {};
      ref = object._changes;
      for (key in ref) {
        value = ref[key];
        data[key] = value;
      }
      ref1 = object.entity.relationships;
      for (i = 0, len = ref1.length; i < len; i++) {
        relation = ref1[i];
        if (!relation.toMany) {
          if (((ref2 = object._relationChanges) != null ? ref2[relation.name] : void 0) !== void 0) {
            if ((ref3 = object._relationChanges) != null ? ref3[relation.name] : void 0) {
              id = this._recordIDForObjectID(object._relationChanges[relation.name].objectID);
              data[relation.name + '_id'] = id;
            } else {
              data[relation.name + '_id'] = null;
            }
          }
        }
      }
      return data;
    };

    MySQLStore.prototype.valuesForObject = function(ObjectID, context) {
      return this.fetchedObjectValuesCache[ObjectID.toString()] || {};
    };

    MySQLStore.prototype.valuesForRelationship = function(relationship, ObjectID, context, callback) {
      var attribute, columns, i, inversedRelationship, len, mainRelationship, ref, sql;
      inversedRelationship = relationship.inverseRelationship();
      sql = null;
      columns = ['`_id` as _id'];
      ref = relationship.destinationEntity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columns.push('`' + attribute.name + '` as ' + attribute.name);
      }
      mainRelationship = this._relationshipByPriority(relationship, inversedRelationship);
      if (relationship.toMany && inversedRelationship.toMany) {
        if (mainRelationship === relationship) {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `' + relationship.name + '_id` FROM `' + this._formatTableName(relationship.entity.name) + '_' + relationship.name + '` WHERE `reflexive` = ' + mysql.escape(this._recordIDForObjectID(ObjectID)) + ')';
        } else {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `reflexive` FROM `' + this._formatTableName(inversedRelationship.entity.name) + '_' + inversedRelationship.name + '` WHERE `' + inversedRelationship.name + '_id` = ' + mysql.escape(this._recordIDForObjectID(ObjectID)) + ')';
        }
      } else {
        if (inversedRelationship.toMany) {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `_id` IN (SELECT `' + relationship.name + '_id` FROM `' + this._formatTableName(relationship.entity.name) + '` WHERE `_id` = ' + mysql.escape(this._recordIDForObjectID(ObjectID)) + ') LIMIT 1';
        } else {
          sql = 'SELECT ' + columns.join(',') + ' FROM `' + this._formatTableName(relationship.destinationEntity.name) + '` WHERE `' + inversedRelationship.name + '_id` = ' + mysql.escape(this._recordIDForObjectID(ObjectID));
        }
      }
      return this.connection.sendRawQuery(sql, (function(_this) {
        return function(err, rows) {
          var _row, ids, j, k, len1, len2, objectID, ref1, row;
          ids = [];
          if (err) {
            return callback(err);
          }
          for (j = 0, len1 = rows.length; j < len1; j++) {
            row = rows[j];
            _row = {};
            ref1 = relationship.destinationEntity.attributes;
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              attribute = ref1[k];
              _row[attribute.name] = row[attribute.name];
            }
            objectID = _this._permanentIDForRecord(relationship.destinationEntity, row._id);
            _this.fetchedObjectValuesCache[objectID.toString()] = _row;
            ids.push(objectID);
          }
          if (relationship.toMany) {
            return callback(null, ids);
          } else {
            return callback(null, ids[0]);
          }
        };
      })(this));
    };

    MySQLStore.prototype.permanentIDsForObjects = function(objects, callback) {
      var i, ids, len, object;
      ids = [];
      for (i = 0, len = objects.length; i < len; i++) {
        object = objects[i];
        ids.push(this._permanentIDForRecord(object.entity, this.permanentIDsCache[object.objectID.toString()]));
      }
      return ids;
    };

    MySQLStore.prototype.newObjectID = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/t' + referenceObject, entity);
    };

    MySQLStore.prototype._permanentIDForRecord = function(entity, referenceObject) {
      return new ManagedObjectID(this.URL + '/' + entity.name + '/p' + referenceObject, entity);
    };

    MySQLStore.prototype._recordIDForObjectID = function(objectID) {
      return objectID.recordId();
    };

    MySQLStore.prototype.syncSchema = function(options, callback) {
      var attribute, columnDefinition, entity, i, inversedRelationship, j, key, len, len1, objectModel, parts, ref, ref1, ref2, ref3, reflexiveRelationship, reflexiveTableName, relationship, schema, sql, sqls, tableName;
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      options = options || {};
      objectModel = this.storeCoordinator.objectModel;
      schema = {};
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        tableName = this._formatTableName(entity.name);
        parts = ['`_id` int(11) NOT NULL AUTO_INCREMENT', 'PRIMARY KEY (`_id`)'];
        ref1 = entity.attributes;
        for (i = 0, len = ref1.length; i < len; i++) {
          attribute = ref1[i];
          columnDefinition = this._columnDefinitionForAttribute(attribute);
          if (columnDefinition) {
            parts.push(columnDefinition);
          } else {
            return callback(new Error('unknown attribute type ' + attribute.type));
          }
        }
        ref2 = entity.relationships;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          relationship = ref2[j];
          if (!relationship.toMany) {
            parts.push('`' + relationship.name + '_id` int(11) DEFAULT NULL');
          }
        }
        if (options.force) {
          sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
        }
        sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
        sql += parts.join(',');
        sql += ') ENGINE=InnoDB  DEFAULT CHARSET=utf8;';
        schema[tableName] = sql;
        ref3 = entity.relationships;
        for (key in ref3) {
          relationship = ref3[key];
          if (relationship.toMany) {
            inversedRelationship = relationship.inverseRelationship();
            if (inversedRelationship.toMany) {
              reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
              reflexiveTableName = this._formatTableName(reflexiveRelationship.entity.name) + '_' + reflexiveRelationship.name;
              if (options.force) {
                sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
              }
              schema[reflexiveTableName] = 'CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))';
            }
          }
        }
      }
      for (key in schema) {
        sql = schema[key];
        sqls.push(sql);
      }
      return async.forEachSeries(sqls, (function(_this) {
        return function(sql, cb) {
          return _this.connection.sendRawQuery(sql, cb);
        };
      })(this), function(err) {
        if (callback) {
          return callback(err);
        }
      });
    };

    MySQLStore.prototype._relationshipByPriority = function(relationship, inversedRelationship) {
      if (relationship.name > inversedRelationship.name) {
        return relationship;
      }
      return inversedRelationship;
    };

    MySQLStore.prototype._formatTableName = function(name) {
      return _.pluralize(name).toLowerCase();
    };

    MySQLStore.prototype._columnDefinitionForAttribute = function(attribute) {
      var defaultValue, definition, type;
      type = null;
      defaultValue = attribute.info["default"] || 'NULL';
      switch (attribute.type) {
        case 'bool':
        case 'boolean':
          type = 'tinyint(1)';
          break;
        case 'string':
        case 'email':
        case 'url':
          type = 'varchar(' + (attribute.options.length || 255) + ')';
          break;
        case 'text':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinytext';
            } else if (attribute.options.length < 65536) {
              type = 'text';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumtext';
            } else if (attribute.options.length < 4294967296) {
              type = 'longtext';
            }
          } else {
            type = 'longtext';
          }
          break;
        case 'data':
          if (attribute.options.length) {
            if (attribute.options.length < 256) {
              type = 'tinyblob';
            } else if (attribute.options.length < 65536) {
              type = 'blob';
            } else if (attribute.options.length < 16777216) {
              type = 'mediumblob';
            } else if (attribute.options.length < 4294967296) {
              type = 'longblob';
            }
          } else {
            type = 'longblob';
          }
          break;
        case 'int':
        case 'integer':
          type = 'int(' + (attribute.options.length || 11) + ')';
          break;
        case 'decimal':
          type = 'decimal(' + (attribute.options.digits || 20) + ',' + (attribute.options.decimals || 5) + ')';
          break;
        case 'float':
          type = 'float';
          break;
        case 'double':
          type = 'double';
          break;
        case 'date':
          type = 'datetime';
          break;
        case 'timestamp':
          type = 'bigint(20)';
          break;
        default:
          return null;
      }
      definition = '`' + attribute.name + '` ' + type + ' DEFAULT ' + defaultValue;
      if (attribute.info.unique) {
        definition += ', UNIQUE(`' + attribute.name + '`)';
      }
      return definition;
    };

    return MySQLStore;

  })(IncrementalStore);

  MySQLConnection = (function(superClass) {
    extend(MySQLConnection, superClass);

    function MySQLConnection(url, store, settings) {
      var ref, ref1;
      this.store = store;
      this.sendRawQuery = bind(this.sendRawQuery, this);
      this.pool = GenericPool.Pool({
        name: "mysql",
        create: function(callback) {
          var connection;
          connection = mysql.createConnection(url, {
            multipleStatements: true
          });
          return connection.connect(function(err) {
            return callback(err, connection);
          });
        },
        destroy: function(connection) {
          return connection.destroy();
        },
        max: (settings != null ? settings.maxConnections : void 0) || (process.NODE_ENV === 'production' ? 100 : 10),
        idleTimeoutMillis: (ref = settings != null ? settings.idletimeoutMillis : void 0) != null ? ref : 60 * 1000,
        reapIntervalMillis: (ref1 = settings != null ? settings.reapIntervalMillis : void 0) != null ? ref1 : 5 * 1000
      });
    }

    MySQLConnection.prototype.sendRawQuery = function(query, params, callback) {
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      return this.pool.acquire((function(_this) {
        return function(err, conn) {
          var error, q;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          try {
            q = conn.query(query, params, function(err, result, fields) {
              _this.pool.release(conn);
              return typeof callback === "function" ? callback(err, result, fields) : void 0;
            });
            if (_this.store.debug) {
              return console.log(q.sql);
            }
          } catch (_error) {
            error = _error;
            _this.pool.release(conn);
            return typeof callback === "function" ? callback(error) : void 0;
          }
        };
      })(this));
    };

    MySQLConnection.prototype.sendQuery = function(query, params, callback) {
      var err, sql;
      if (typeof params === 'function') {
        callback = params;
        params = null;
      }
      try {
        sql = query.getSQL();
        return this.sendRawQuery(sql, params, callback);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    MySQLConnection.prototype.createTransaction = function(callback) {
      return this.pool.acquire(function(err, connection) {
        if (err) {
          return callback(err);
        }
        return callback(new Transaction(connection));
      });
    };

    MySQLConnection.prototype.releaseTransaction = function(transaction) {
      return this.pool.release(transaction.connection);
    };

    return MySQLConnection;

  })(Object);

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    function Transaction(connection1) {
      this.connection = connection1;
      this.started = false;
      this.autoRollback = true;
      this.debug = false;
    }

    Transaction.prototype.ensureBegin = function(callback) {
      if (this.started) {
        return callback();
      }
      this.started = true;
      return this.connection.query('BEGIN', function(err) {
        return callback(err);
      });
    };

    Transaction.prototype.sendQuery = function(query, callback) {
      var q;
      if (!this.connection) {
        throw new Error('connection released or not set');
      }
      q = typeof query === 'string' ? query : query.getSQL();
      return this.ensureBegin((function(_this) {
        return function(err) {
          if (err) {
            if (self.autoRollback) {
              return _this.rollback(function() {
                return callback(err);
              });
            } else {
              return callback(err);
            }
          }
          if (_this.debug) {
            console.log(q);
          }
          return _this.connection.query(q, callback);
        };
      })(this));
    };

    Transaction.prototype.commit = function(callback) {
      return this.connection.query('COMMIT', callback);
    };

    Transaction.prototype.rollback = function(callback) {
      return this.connection.query('ROLLBACK', callback);
    };

    return Transaction;

  })(Object);

  module.exports = MySQLStore;

}).call(this);
