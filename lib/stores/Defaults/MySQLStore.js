// Generated by CoffeeScript 1.10.0
(function() {
  var GenericPool, GenericSQLStore, ManagedObjectID, MySQLConnection, MySQLStore, PersistentStoreRequest, Predicate, SQLConnection, _, async, e, error, mysql,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  GenericSQLStore = require('./GenericSQLStore');

  PersistentStoreRequest = require('./../PersistentStoreRequest');

  GenericPool = require('generic-pool');

  async = require('async');

  ManagedObjectID = require('./../../ManagedObjectID');

  Predicate = require('./../../FetchClasses/Predicate');

  SQLConnection = require('./SQLConnection');

  try {
    require('mysql');
  } catch (error) {
    e = error;
    throw new Error('mysql module is required to use MySQL storage, please install it by running npm install --save mysql');
  }

  mysql = require('mysql');

  _ = require('underscore');

  _.mixin(require('underscore.inflections'));

  MySQLStore = (function(superClass) {
    extend(MySQLStore, superClass);

    function MySQLStore() {
      return MySQLStore.__super__.constructor.apply(this, arguments);
    }

    MySQLStore.prototype.quoteSymbol = '`';

    MySQLStore.prototype.createConnection = function(url) {
      return new MySQLConnection(url, this);
    };

    MySQLStore.prototype.createSchemaQueries = function(options) {
      var entity, key, objectModel, ref, sqls;
      if (options == null) {
        options = {};
      }
      objectModel = this.storeCoordinator.objectModel;
      sqls = [];
      ref = objectModel.entities;
      for (key in ref) {
        entity = ref[key];
        sqls = sqls.concat(this.createEntityQueries(entity, options.force));
      }
      sqls.push('CREATE TABLE IF NOT EXISTS `_meta` (`key` varchar(10) NOT NULL,`value` varchar(250) NOT NULL,PRIMARY KEY (`key`)) ENGINE=InnoDB  DEFAULT CHARSET=utf8');
      sqls.push('INSERT INTO `_meta` VALUES(\'version\',\'' + objectModel.version + '\') ON DUPLICATE KEY UPDATE `value` = VALUES(`value`)');
      return sqls;
    };

    MySQLStore.prototype.createEntityQueries = function(entity, force, options) {
      var attribute, columnDefinition, i, index, j, k, len, len1, len2, parts, ref, ref1, ref2, relationship, sql, sqls, tableName;
      if (options == null) {
        options = {};
      }
      sqls = [];
      tableName = this._formatTableName(entity.name);
      parts = ['`_id` int(11) NOT NULL AUTO_INCREMENT', 'PRIMARY KEY (`_id`)'];
      ref = entity.attributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attribute = ref[i];
        columnDefinition = this._columnDefinitionForAttribute(attribute);
        if (columnDefinition) {
          parts.push(columnDefinition);
        } else {
          throw new Error('unknown attribute type ' + attribute.type);
        }
      }
      ref1 = this._indexesForEntity(entity);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        index = ref1[j];
        parts.push((index.type === 'unique' ? 'UNIQUE ' : '') + 'KEY `' + index.name + '` (`' + index.columns.join('`,`') + '`)');
      }
      ref2 = entity.relationships;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        relationship = ref2[k];
        if (!relationship.toMany) {
          parts.push(this.relationshipColumnDefinition(relationship));
        }
      }
      if (force) {
        sqls.push('DROP TABLE IF EXISTS `' + tableName + '`');
      }
      sql = 'CREATE TABLE IF NOT EXISTS `' + tableName + '` (';
      sql += parts.join(',');
      sql += ') ENGINE=InnoDB  DEFAULT CHARSET=utf8;';
      sqls.push(sql);
      if (!options.ignoreRelationships) {
        sqls = sqls.concat(this.createEntityRelationshipQueries(entity, force));
      }
      return sqls;
    };

    MySQLStore.prototype._renameRelationshipQuery = function(tableName, relationshipFrom, relationshipTo) {
      return 'ALTER TABLE ' + this.quoteSymbol + tableName + this.quoteSymbol + ' CHANGE ' + this.quoteSymbol + relationshipFrom.name + '_id' + this.quoteSymbol + ' ' + this.quoteSymbol + relationshipTo.name + '_id' + this.quoteSymbol + ' int(11) DEFAULT NULL';
    };

    MySQLStore.prototype._renameAttributeQuery = function(tableName, attributeFrom, attributeTo) {
      return 'ALTER TABLE ' + this.quoteSymbol + tableName + this.quoteSymbol + ' CHANGE ' + this.quoteSymbol + attributeFrom.name + this.quoteSymbol + ' ' + this._columnDefinitionForAttribute(attributeTo);
    };

    MySQLStore.prototype.createRelationshipQueries = function(relationship, force) {
      var inversedRelationship, reflexiveRelationship, reflexiveTableName, sqls;
      sqls = [];
      if (relationship.toMany) {
        inversedRelationship = relationship.inverseRelationship();
        if (inversedRelationship.toMany) {
          reflexiveRelationship = this._relationshipByPriority(relationship, inversedRelationship);
          reflexiveTableName = this._getMiddleTableNameForManyToManyRelation(reflexiveRelationship);
          if (force) {
            sqls.push('DROP TABLE IF EXISTS `' + reflexiveTableName + '`');
          }
          sqls.push('CREATE TABLE IF NOT EXISTS `' + reflexiveTableName + '` (`' + reflexiveRelationship.name + '_id` int(11) NOT NULL,`reflexive` int(11) NOT NULL, PRIMARY KEY (`' + reflexiveRelationship.name + '_id`,`reflexive`))');
        }
      }
      return sqls;
    };

    MySQLStore.prototype.columnTypeForAttribute = function(attribute) {
      var validValues;
      switch (attribute.persistentType) {
        case 'enum':
          validValues = attribute.info.values;
          if (typeof validValues === 'string') {
            validValues = validValues.split(',');
          }
          return 'ENUM(\'' + validValues.join('\',\'') + '\')';
        default:
          return MySQLStore.__super__.columnTypeForAttribute.call(this, attribute);
      }
    };

    return MySQLStore;

  })(GenericSQLStore);

  MySQLConnection = (function(superClass) {
    extend(MySQLConnection, superClass);

    function MySQLConnection() {
      return MySQLConnection.__super__.constructor.apply(this, arguments);
    }

    MySQLConnection.prototype.connect = function(callback) {
      this.connection = mysql.createConnection(this.url, {
        multipleStatements: true
      });
      this.connection.connect((function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return callback(null, _this.connection);
        };
      })(this));
      return this.connection.on('error', function(err) {
        this.valid = false;
        return this.log('mysql connection error', err);
      });
    };

    MySQLConnection.prototype.close = function() {
      return this.connection.destroy();
    };

    MySQLConnection.prototype.execute = function(query, callback) {
      return this.connection.query(query, callback);
    };

    MySQLConnection.prototype.createRow = function(tableName, callback) {
      var query;
      query = 'INSERT INTO ' + tableName + ' (`_id`) VALUES (NULL)';
      return this.execute(query, function(err, result) {
        if (err) {
          return callback(err);
        }
        return callback(null, result.insertId);
      });
    };

    return MySQLConnection;

  })(SQLConnection);

  module.exports = MySQLStore;

}).call(this);
