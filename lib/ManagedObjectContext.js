// Generated by CoffeeScript 1.10.0
(function() {
  var FetchRequest, Lock, ManagedObject, ManagedObjectContext, ManagedObjectID, Predicate, Promise, RelationshipDescription, SortDescriptor, ac, async,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ManagedObject = require('./ManagedObject');

  ManagedObjectID = require('./ManagedObjectID');

  FetchRequest = require('./FetchRequest');

  Predicate = require('./FetchClasses/Predicate');

  SortDescriptor = require('./FetchClasses/SortDescriptor');

  RelationshipDescription = require('./Descriptors/RelationshipDescription');

  async = require('async');

  ac = require('array-control');

  Lock = require('lock');

  Promise = require('bluebird');

  ManagedObjectContext = (function(superClass) {
    extend(ManagedObjectContext, superClass);

    function ManagedObjectContext(storeCoordinator) {
      this.storeCoordinator = storeCoordinator;
      this.insertedObjects = [];
      this.updatedObjects = [];
      this.deletedObjects = [];
      this.registeredObjects = [];
      this.locked = false;
      this.lock = new Lock();
      this.destroyed = false;
    }

    ManagedObjectContext.prototype.hasChanges = function() {
      return this.insertedObjects.length > 0 || this.updatedObjects.length > 0 || this.deletedObjects.length > 0;
    };

    ManagedObjectContext.prototype.insertObject = function(object) {
      var attributeDescription, defaultValue, i, len, ref, values;
      if (this.locked) {
        throw new Error('context is locked');
      }
      if (object.managedObjectContext !== this) {
        throw new Error('cannot insert object to another context');
      }
      if (indexOf.call(this.insertedObjects, object) < 0) {
        object._isFault = false;
        values = {};
        ref = object.entity.attributes;
        for (i = 0, len = ref.length; i < len; i++) {
          attributeDescription = ref[i];
          defaultValue = attributeDescription.defaultValue();
          if (defaultValue !== null && !attributeDescription.isTransient()) {
            values[attributeDescription.name] = defaultValue;
          }
        }
        object._data = {};
        object.setValues(values, {
          privates: true
        });
        object._isInserted = true;
        object._isDeleted = false;
        object._objectID = this.storeCoordinator.temporaryObjectID(object);
        ac.addObject(this.insertedObjects, object);
        ac.addObject(this.registeredObjects, object);
        object.awakeFromInsert();
      }
      return ac.removeObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.deleteObject = function(object) {
      if (this.locked) {
        throw new Error('context is locked');
      }
      return this._deleteObjectWithoutLockCheck(object);
    };

    ManagedObjectContext.prototype._deleteObjectWithoutLockCheck = function(object) {
      if (object.managedObjectContext !== this) {
        throw new Error('cannot delete object from another context');
      }
      ac.removeObject(this.insertedObjects, object);
      object._isDeleted = true;
      return ac.addObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.createObjectWithName = function(entityName) {
      return this.storeCoordinator.objectModel.insertObjectIntoContext(entityName, this);
    };

    ManagedObjectContext.prototype.create = function(entityName, data, allowedAttributes) {
      var object;
      object = this.createObjectWithName(entityName);
      object.setValues(data, allowedAttributes);
      return object;
    };

    ManagedObjectContext.prototype.getObjectWithId = function(entityName, id, callback) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return async.nextTick(function() {
            var entity;
            entity = _this.storeCoordinator.objectModel.getEntity(entityName);
            if (!entity) {
              return reject(new Error('entity ' + entityName + ' not found'));
            }
            return _this.getObjectWithObjectID(new ManagedObjectID(id, entity)).then(resolve)["catch"](reject);
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.getObjectWithObjectID = function(ObjectID, callback) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var request;
          request = new FetchRequest(ObjectID.entity);
          request.setLimit(1);
          request.predicate = new Predicate(ObjectID);
          return _this.storeCoordinator.execute(request, _this, function(err, objects) {
            if (err) {
              return reject(err);
            }
            if (objects[0]) {
              ac.addObject(_this.registeredObjects, objects[0]);
              return resolve(objects[0]);
            } else {
              return resolve(null);
            }
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.getObjects = function(entityName, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.storeCoordinator.execute(_this._getFetchRequest(entityName, options), _this, function(err, objects) {
            if (err) {
              return reject(err);
            } else {
              ac.addObjects(_this.registeredObjects, objects);
              return resolve(objects);
            }
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.fetch = function(entityName, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var request;
          request = _this._getFetchRequest(entityName, options);
          request.resultType = FetchRequest.RESULT_TYPE.VALUES;
          return _this.storeCoordinator.execute(request, _this, function(err, values) {
            if (err) {
              return reject(err);
            } else {
              return resolve(values);
            }
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype._getFetchRequest = function(entityName, options) {
      var ascending, having, havingPredicate, i, len, predicate, request, sort, sortDescriptors, sortItem, where;
      options = options || {};
      predicate = null;
      havingPredicate = null;
      sortDescriptors = [];
      if (typeof options.where === 'string') {
        predicate = new Predicate(options.where);
      } else if (Array.isArray(options.where)) {
        where = options.where.slice();
        where.unshift(null);
        predicate = new (Function.prototype.bind.apply(Predicate, where));
      } else if (typeof options.where === 'object') {
        predicate = new Predicate(options.where);
      }
      if (typeof options.having === 'string') {
        havingPredicate = new Predicate(options.having);
      } else if (Array.isArray(options.having)) {
        having = options.having.slice();
        having.unshift(null);
        havingPredicate = new (Function.prototype.bind.apply(Predicate, having));
      } else if (typeof options.having === 'object') {
        havingPredicate = new Predicate(options.having);
      }
      sort = options.sort || options.order;
      if (typeof sort === 'string') {
        sort = [sort];
      }
      if (Array.isArray(sort)) {
        for (i = 0, len = sort.length; i < len; i++) {
          sortItem = sort[i];
          ascending = true;
          if (sortItem[0] === '-') {
            ascending = false;
            sortItem = sortItem.substring(1);
          }
          sortDescriptors.push(new SortDescriptor(sortItem, ascending));
        }
      }
      request = new FetchRequest(this.storeCoordinator.objectModel.getEntity(entityName), predicate, sortDescriptors);
      request.predicate = predicate;
      request.havingPredicate = havingPredicate;
      request.sortDescriptors = sortDescriptors;
      if (options.offset && !options.limit) {
        throw new Error('limit must be supplied when fetching with offset');
      }
      if (options.limit) {
        request.setLimit(options.limit);
      }
      if (options.offset) {
        request.setOffset(options.offset);
      }
      request.fields = options.fields;
      request.group = options.group;
      return request;
    };

    ManagedObjectContext.prototype.getObject = function(entityName, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          options = options || {};
          options.limit = 1;
          return _this.getObjects(entityName, options).then(function(objects) {
            if (objects.length > 0) {
              return resolve(objects[0]);
            } else {
              return resolve(null);
            }
          })["catch"](reject);
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.getOrCreateObject = function(entityName, options, defaultValues, callback) {
      if (typeof defaultValues === 'function') {
        callback = defaultValues;
        defaultValues = void 0;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.lock(entityName, function(release) {
            return _this.getObject(entityName, options, function(err, object) {
              if (err) {
                release()();
                return reject(err);
              }
              if (!object) {
                object = _this.create(entityName, defaultValues);
              }
              resolve(object);
              return release()();
            });
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.getObjectsCount = function(entityName, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.storeCoordinator.numberOfObjectsForFetchRequest(_this._getFetchRequest(entityName, options), function(err, count) {
            if (err) {
              return reject(err);
            } else {
              return resolve(count);
            }
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype._getObjectsForRelationship = function(relationship, object, context, callback) {
      if (object.objectID.isTemporaryID) {
        return callback(null, []);
      }
      return this.storeCoordinator._valuesForForRelationship(relationship, object.objectID, context, (function(_this) {
        return function(err, objects) {
          if (err) {
            return callback(err);
          }
          ac.addObjects(_this.registeredObjects, objects);
          return callback(null, objects);
        };
      })(this));
    };

    ManagedObjectContext.prototype.saveAndDestroy = function(callback) {
      var promise;
      promise = this.save().then((function(_this) {
        return function() {
          _this.destroy();
          if (callback) {
            return callback();
          }
        };
      })(this));
      if (callback) {
        return promise["catch"](callback);
      }
    };

    ManagedObjectContext.prototype.save = function(callback) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var allObjects, i, j, len, len1, obj, ref;
          if (_this.locked) {
            throw new Error('context is locked');
          }
          allObjects = [];
          ref = _this.insertedObjects.concat(_this.updatedObjects, _this.deletedObjects);
          for (i = 0, len = ref.length; i < len; i++) {
            obj = ref[i];
            if (indexOf.call(allObjects, obj) < 0) {
              allObjects.push(obj);
            }
          }
          for (j = 0, len1 = allObjects.length; j < len1; j++) {
            obj = allObjects[j];
            obj.willSave();
          }
          _this.locked = true;
          return async.nextTick(function() {
            if (!_this.hasChanges) {
              _this.locked = false;
              return resolve();
            }
            return _this._processDeletedObjects(function(err) {
              if (err) {
                _this.locked = false;
                return reject(err);
              }
              return _this.storeCoordinator.saveContext(_this, function(err) {
                var k, l, len2, len3, len4, len5, m, n, object, ref1, ref2, ref3;
                if (!err) {
                  ref1 = _this.insertedObjects;
                  for (k = 0, len2 = ref1.length; k < len2; k++) {
                    object = ref1[k];
                    object._changes = null;
                    object._relationChanges = null;
                    object._isInserted = false;
                  }
                  ref2 = _this.updatedObjects;
                  for (l = 0, len3 = ref2.length; l < len3; l++) {
                    object = ref2[l];
                    object._changes = null;
                    object._relationChanges = null;
                    object._isUpdated = false;
                  }
                  ref3 = _this.deletedObjects;
                  for (m = 0, len4 = ref3.length; m < len4; m++) {
                    object = ref3[m];
                    object._isDeleted = false;
                  }
                  _this.insertedObjects = [];
                  _this.updatedObjects = [];
                  _this.deletedObjects = [];
                }
                _this.locked = false;
                if (err) {
                  return reject(err);
                } else {
                  for (n = 0, len5 = allObjects.length; n < len5; n++) {
                    obj = allObjects[n];
                    obj.didSave();
                  }
                  return resolve();
                }
              });
            });
          });
        };
      })(this)).asCallback(callback);
    };

    ManagedObjectContext.prototype.reset = function() {
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.registeredObjects = [];
      this.updatedObjects = [];
      return this.deletedObjects = [];
    };

    ManagedObjectContext.prototype.destroy = function() {
      if (this.destroyed) {
        throw new Error('destroying already destroyed context');
      }
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.destroyed = true;
      delete this.registeredObjects;
      delete this.insertedObjects;
      delete this.updatedObjects;
      delete this.deletedObjects;
      return delete this.storeCoordinator;
    };

    Object.defineProperties(ManagedObjectContext.prototype, {
      hasChanges: {
        get: ManagedObjectContext.prototype.hasChanges
      }
    });

    ManagedObjectContext.prototype._processDeletedObjects = function(callback) {
      return async.forEach(this.deletedObjects, (function(_this) {
        return function(object, cb) {
          return object.prepareForDeletion(cb);
        };
      })(this), callback);
    };

    ManagedObjectContext.prototype._didUpdateObject = function(object) {
      if (this.destroyed) {
        throw new Error('updating values on object on destroyed context');
      }
      if (this.locked) {
        throw new Error('cannot update object when it\'s context is locked');
      }
      if (indexOf.call(this.updatedObjects, object) < 0) {
        return ac.addObject(this.updatedObjects, object);
      }
    };

    return ManagedObjectContext;

  })(Object);

  module.exports = ManagedObjectContext;

}).call(this);
