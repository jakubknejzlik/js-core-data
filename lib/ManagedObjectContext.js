// Generated by CoffeeScript 1.10.0
(function() {
  var FetchRequest, Lock, ManagedObject, ManagedObjectContext, ManagedObjectID, Predicate, Q, RelationshipDescription, SortDescriptor, ac, async,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ManagedObject = require('./ManagedObject');

  ManagedObjectID = require('./ManagedObjectID');

  FetchRequest = require('./FetchRequest');

  Predicate = require('./FetchClasses/Predicate');

  SortDescriptor = require('./FetchClasses/SortDescriptor');

  RelationshipDescription = require('./Descriptors/RelationshipDescription');

  async = require('async');

  ac = require('array-control');

  Lock = require('lock');

  Q = require('q');

  ManagedObjectContext = (function(superClass) {
    extend(ManagedObjectContext, superClass);

    function ManagedObjectContext(storeCoordinator) {
      this.storeCoordinator = storeCoordinator;
      this.insertedObjects = [];
      this.updatedObjects = [];
      this.deletedObjects = [];
      this.registeredObjects = [];
      this.locked = false;
      this.lock = new Lock();
      this.destroyed = false;
    }

    ManagedObjectContext.prototype.hasChanges = function() {
      return this.insertedObjects.length > 0 || this.updatedObjects.length > 0 || this.deletedObjects.length > 0;
    };

    ManagedObjectContext.prototype.insertObject = function(object) {
      var attributeDescription, i, len, ref, values;
      if (this.locked) {
        throw new Error('context is locked');
      }
      if (object.managedObjectContext !== this) {
        throw new Error('cannot insert object to another context');
      }
      if (indexOf.call(this.insertedObjects, object) < 0) {
        object._isFault = false;
        values = {};
        ref = object.entity.attributes;
        for (i = 0, len = ref.length; i < len; i++) {
          attributeDescription = ref[i];
          values[attributeDescription.name] = attributeDescription.defaultValue();
        }
        object._data = {};
        object.setValues(values);
        object._isInserted = true;
        object._isDeleted = false;
        object._objectID = this.storeCoordinator.temporaryObjectID(object);
        ac.addObject(this.insertedObjects, object);
        ac.addObject(this.registeredObjects, object);
      }
      return ac.removeObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.deleteObject = function(object) {
      if (this.locked) {
        throw new Error('context is locked');
      }
      return this._deleteObjectWithoutLockCheck(object);
    };

    ManagedObjectContext.prototype._deleteObjectWithoutLockCheck = function(object) {
      if (object.managedObjectContext !== this) {
        throw new Error('cannot delete object from another context');
      }
      ac.removeObject(this.insertedObjects, object);
      object._isDeleted = true;
      return ac.addObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.createObjectWithName = function(entityName) {
      return this.storeCoordinator.objectModel.insertObjectIntoContext(entityName, this);
    };

    ManagedObjectContext.prototype.create = function(entityName, data, allowedAttributes) {
      var object;
      object = this.createObjectWithName(entityName);
      object.setValues(data, allowedAttributes);
      return object;
    };

    ManagedObjectContext.prototype.getObjectWithId = function(entityName, id, callback) {
      var deferred;
      deferred = Q.defer();
      async.nextTick((function(_this) {
        return function() {
          var entity;
          entity = _this.storeCoordinator.objectModel.getEntity(entityName);
          if (!entity) {
            return deferred.reject(new Error('entity ' + entityName + ' not found'));
          }
          return _this.getObjectWithObjectID(new ManagedObjectID(id, entity)).then(deferred.resolve)["catch"](deferred.reject);
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.getObjectWithObjectID = function(ObjectID, callback) {
      var deferred, request;
      deferred = Q.defer();
      request = new FetchRequest(ObjectID.entity);
      request.setLimit(1);
      request.predicate = new Predicate(ObjectID);
      this.storeCoordinator.execute(request, this, (function(_this) {
        return function(err, objects) {
          if (err) {
            return deferred.reject(err);
          }
          if (objects[0]) {
            ac.addObject(_this.registeredObjects, objects[0]);
            return deferred.resolve(objects[0]);
          } else {
            return deferred.resolve(null);
          }
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.getObjects = function(entityName, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      this.storeCoordinator.execute(this._getFetchRequest(entityName, options), this, (function(_this) {
        return function(err, objects) {
          if (err) {
            return deferred.reject(err);
          } else {
            ac.addObjects(_this.registeredObjects, objects);
            return deferred.resolve(objects);
          }
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.fetch = function(entityName, options, callback) {
      var deferred, request;
      deferred = Q.defer();
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      request = this._getFetchRequest(entityName, options);
      request.resultType = FetchRequest.RESULT_TYPE.VALUES;
      this.storeCoordinator.execute(request, this, (function(_this) {
        return function(err, values) {
          if (err) {
            return deferred.reject(err);
          } else {
            return deferred.resolve(values);
          }
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype._getFetchRequest = function(entityName, options) {
      var ascending, i, len, predicate, request, sort, sortDescriptors, sortItem, where;
      options = options || {};
      predicate = null;
      sortDescriptors = [];
      if (typeof options.where === 'string') {
        predicate = new Predicate(options.where);
      } else if (Array.isArray(options.where)) {
        where = options.where.slice();
        where.unshift(null);
        predicate = new (Function.prototype.bind.apply(Predicate, where));
      }
      sort = options.sort || options.order;
      if (typeof sort === 'string') {
        sort = [sort];
      }
      if (Array.isArray(sort)) {
        for (i = 0, len = sort.length; i < len; i++) {
          sortItem = sort[i];
          ascending = true;
          if (sortItem[0] === '-') {
            ascending = false;
            sortItem = sortItem.substring(1);
          }
          sortDescriptors.push(new SortDescriptor(sortItem, ascending));
        }
      }
      request = new FetchRequest(this.storeCoordinator.objectModel.getEntity(entityName), predicate, sortDescriptors);
      request.predicate = predicate;
      request.sortDescriptors = sortDescriptors;
      if (options.offset && !options.limit) {
        throw new Error('limit must be supplied when fetching with offset');
      }
      if (options.limit) {
        request.setLimit(options.limit);
      }
      if (options.offset) {
        request.setOffset(options.offset);
      }
      request.fields = options.fields;
      request.group = options.group;
      return request;
    };

    ManagedObjectContext.prototype.getObject = function(entityName, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      this.getObjects(entityName, options).then(function(objects) {
        if (objects.length > 0) {
          return deferred.resolve(objects[0]);
        } else {
          return deferred.resolve(null);
        }
      })["catch"](deferred.reject);
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.getOrCreateObject = function(entityName, options, defaultValues, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof defaultValues === 'function') {
        callback = defaultValues;
        defaultValues = void 0;
      }
      this.lock(entityName, (function(_this) {
        return function(release) {
          return _this.getObject(entityName, options, function(err, object) {
            if (err) {
              release()();
              return deferred.reject(err);
            }
            if (!object) {
              object = _this.create(entityName, defaultValues);
            }
            deferred.resolve(object);
            return release()();
          });
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.getObjectsCount = function(entityName, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      this.storeCoordinator.numberOfObjectsForFetchRequest(this._getFetchRequest(entityName, options), function(err, count) {
        if (err) {
          return deferred.reject(err);
        } else {
          return deferred.resolve(count);
        }
      });
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype._getObjectsForRelationship = function(relationship, object, context, callback) {
      if (object.objectID.isTemporaryID) {
        return callback(null, []);
      }
      return this.storeCoordinator._valuesForForRelationship(relationship, object.objectID, context, function(err, objects) {
        return callback(err, objects);
      });
    };

    ManagedObjectContext.prototype.saveAndDestroy = function(callback) {
      return this.save().then((function(_this) {
        return function() {
          _this.destroy();
          if (callback) {
            return callback();
          }
        };
      })(this))["catch"](callback);
    };

    ManagedObjectContext.prototype.save = function(callback) {
      var deferred;
      deferred = Q.defer();
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.locked = true;
      async.nextTick((function(_this) {
        return function() {
          if (!_this.hasChanges) {
            _this.locked = false;
            return deferred.resolve();
          }
          return _this._processDeletedObjects(function(err) {
            if (err) {
              _this.locked = false;
              return deferred.reject(err);
            }
            return _this.storeCoordinator.saveContext(_this, function(err) {
              var i, j, k, len, len1, len2, object, ref, ref1, ref2;
              if (!err) {
                ref = _this.insertedObjects;
                for (i = 0, len = ref.length; i < len; i++) {
                  object = ref[i];
                  object._changes = null;
                  object._relationChanges = null;
                  object._isInserted = false;
                }
                ref1 = _this.updatedObjects;
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                  object = ref1[j];
                  object._changes = null;
                  object._relationChanges = null;
                  object._isUpdated = false;
                }
                ref2 = _this.deletedObjects;
                for (k = 0, len2 = ref2.length; k < len2; k++) {
                  object = ref2[k];
                  object._isDeleted = false;
                }
                _this.insertedObjects = [];
                _this.updatedObjects = [];
                _this.deletedObjects = [];
              }
              _this.locked = false;
              if (err) {
                return deferred.reject(err);
              } else {
                return deferred.resolve();
              }
            });
          });
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    ManagedObjectContext.prototype.reset = function() {
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.registeredObjects = [];
      this.updatedObjects = [];
      return this.deletedObjects = [];
    };

    ManagedObjectContext.prototype.destroy = function() {
      if (this.destroyed) {
        throw new Error('destroying already destroyed context');
      }
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.destroyed = true;
      delete this.registeredObjects;
      delete this.insertedObjects;
      delete this.updatedObjects;
      delete this.deletedObjects;
      return delete this.storeCoordinator;
    };

    Object.defineProperties(ManagedObjectContext.prototype, {
      hasChanges: {
        get: ManagedObjectContext.prototype.hasChanges
      }
    });

    ManagedObjectContext.prototype._processDeletedObjects = function(callback) {
      return async.forEach(this.deletedObjects, (function(_this) {
        return function(object, cb) {
          return object.prepareForDeletion(cb);
        };
      })(this), (function(_this) {
        return function(err) {
          var dels, i, len, obj, ref;
          if (err) {
            return callback(err);
          }
          dels = [];
          ref = _this.deletedObjects;
          for (i = 0, len = ref.length; i < len; i++) {
            obj = ref[i];
            dels.push(obj);
          }
          return async.forEach(dels, function(object, cb) {
            return _this._deleteObjectsRelationships(object, cb);
          }, callback);
        };
      })(this));
    };

    ManagedObjectContext.prototype._deleteObjectsRelationships = function(object, callback) {
      return async.forEach(object.entity.relationships, (function(_this) {
        return function(relationship, cb) {
          switch (relationship.deleteRule) {
            case RelationshipDescription.deleteRules.DENY:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                var canDelete, i, len, obj;
                if (err) {
                  return cb(err);
                }
                canDelete = true;
                if (objects.length > 0) {
                  for (i = 0, len = objects.length; i < len; i++) {
                    obj = objects[i];
                    canDelete = canDelete && obj.isDeleted;
                  }
                } else {
                  canDelete = true;
                }
                if (!canDelete) {
                  return cb(new Error('cannot delete object, deletion denied for relationship ' + relationship.entity.name + '->' + relationship.name));
                } else {
                  return cb();
                }
              });
            case RelationshipDescription.deleteRules.NULLIFY:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                var i, len, obj;
                if (err) {
                  return cb(err);
                }
                if (objects) {
                  for (i = 0, len = objects.length; i < len; i++) {
                    obj = objects[i];
                    object._removeObjectFromRelation(obj, relationship, relationship.inverseRelationship(), true, false);
                    obj._removeObjectFromRelation(object, relationship.inverseRelationship(), relationship, true, false);
                  }
                }
                return cb();
              });
            case RelationshipDescription.deleteRules.CASCADE:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                if (err) {
                  return cb(err);
                }
                if (objects) {
                  return async.forEach(objects, function(obj, _cb) {
                    _this._deleteObjectWithoutLockCheck(obj);
                    return _this._deleteObjectsRelationships(obj, _cb);
                  }, cb);
                } else {
                  return cb();
                }
              });
            default:
              return cb(new Error('not implemented ' + relationship.deleteRule));
          }
        };
      })(this), callback);
    };

    ManagedObjectContext.prototype._didUpdateObject = function(object) {
      if (this.destroyed) {
        throw new Error('updating values on object on destroyed context');
      }
      if (this.locked) {
        throw new Error('cannot update object when it\'s context is locked');
      }
      if (indexOf.call(this.updatedObjects, object) < 0) {
        return ac.addObject(this.updatedObjects, object);
      }
    };

    return ManagedObjectContext;

  })(Object);

  module.exports = ManagedObjectContext;

}).call(this);
