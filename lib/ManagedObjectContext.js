// Generated by CoffeeScript 1.9.3
(function() {
  var FetchRequest, ManagedObject, ManagedObjectContext, ManagedObjectID, Predicate, RelationshipDescription, SortDescriptor, ac, async,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  ManagedObject = require('./ManagedObject');

  ManagedObjectID = require('./ManagedObjectID');

  FetchRequest = require('./FetchRequest');

  Predicate = require('./FetchClasses/Predicate');

  SortDescriptor = require('./FetchClasses/SortDescriptor');

  RelationshipDescription = require('./Descriptors/RelationshipDescription');

  ac = require('array-control');

  ManagedObjectContext = (function(superClass) {
    extend(ManagedObjectContext, superClass);

    function ManagedObjectContext(storeCoordinator) {
      this.storeCoordinator = storeCoordinator;
      this.insertedObjects = [];
      this.updatedObjects = [];
      this.deletedObjects = [];
      this.registeredObjects = [];
      this.locked = false;
    }

    ManagedObjectContext.prototype.hasChanges = function() {
      return this.insertedObjects.length > 0 || this.updatedObjects.length > 0 || this.deletedObjects.length > 0;
    };

    ManagedObjectContext.prototype.insertObject = function(object) {
      if (this.locked) {
        throw new Error('context is locked');
      }
      if (object.managedObjectContext !== this) {
        throw new Error('cannot insert object to another context');
      }
      if (indexOf.call(this.insertedObjects, object) < 0) {
        object._isFault = false;
        object._data = {};
        object._isInserted = true;
        object._isDeleted = false;
        object._objectID = this.storeCoordinator.temporaryObjectID(object);
        ac.addObject(this.insertedObjects, object);
        ac.addObject(this.registeredObjects, object);
      }
      return ac.removeObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.deleteObject = function(object) {
      if (this.locked) {
        throw new Error('context is locked');
      }
      return this._deleteObjectWithoutLockCheck(object);
    };

    ManagedObjectContext.prototype._deleteObjectWithoutLockCheck = function(object) {
      if (object.managedObjectContext !== this) {
        throw new Error('cannot delete object from another context');
      }
      ac.removeObject(this.insertedObjects, object);
      object._isDeleted = true;
      return ac.addObject(this.deletedObjects, object);
    };

    ManagedObjectContext.prototype.createObjectWithName = function(entityName) {
      return this.storeCoordinator.objectModel.insertObjectIntoContext(entityName, this);
    };

    ManagedObjectContext.prototype.create = function(entityName, data) {
      var key, object, value;
      object = this.createObjectWithName(entityName);
      for (key in data) {
        value = data[key];
        object[key] = value;
      }
      return object;
    };

    ManagedObjectContext.prototype.getObjectWithId = function(entityName, id, callback) {
      var entity;
      entity = this.storeCoordinator.objectModel.getEntity(entityName);
      if (!entity) {
        return callback(new Error('entity ' + entityName + ' not found'));
      }
      return this.getObjectWithObjectID(new ManagedObjectID(id, entity), callback);
    };

    ManagedObjectContext.prototype.getObjectWithObjectID = function(ObjectID, callback) {
      var request;
      request = new FetchRequest(ObjectID.entity);
      request.setLimit(1);
      request.predicate = new Predicate(ObjectID);
      return this.storeCoordinator.execute(request, this, (function(_this) {
        return function(err, objects) {
          if (err) {
            return callback(err);
          }
          if (objects[0]) {
            ac.addObject(_this.registeredObjects, objects[0]);
            return callback(null, objects[0]);
          } else {
            return callback(null, null);
          }
        };
      })(this));
    };

    ManagedObjectContext.prototype.getObjects = function(entityName, options, callback) {
      var ascending, i, len, predicate, request, sort, sortDescriptors, sortItem, where;
      if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      options = options || {};
      predicate = null;
      sortDescriptors = [];
      if (typeof options.where === 'string') {
        predicate = new Predicate(options.where);
      } else if (Array.isArray(options.where)) {
        where = JSON.parse(JSON.stringify(options.where));
        where.unshift(null);
        predicate = new (Function.prototype.bind.apply(Predicate, where));
      }
      sort = options.sort;
      if (typeof sort === 'string') {
        sort = [sort];
      }
      if (Array.isArray(sort)) {
        for (i = 0, len = sort.length; i < len; i++) {
          sortItem = sort[i];
          ascending = true;
          if (sortItem[0] === '-') {
            ascending = false;
            sortItem = sortItem.substring(1);
          }
          sortDescriptors.push(new SortDescriptor(sortItem, ascending));
        }
      }
      request = new FetchRequest(this.storeCoordinator.objectModel.getEntity(entityName), predicate, sortDescriptors);
      request.predicate = predicate;
      request.sortDescriptors = sortDescriptors;
      if (options.offset && !options.limit) {
        throw new Error('limit must be supplied when fetching with offset');
      }
      if (options.limit) {
        request.setLimit(options.limit);
      }
      if (options.offset) {
        request.setOffset(options.offset);
      }
      return this.storeCoordinator.execute(request, this, (function(_this) {
        return function(err, objects) {
          if (!err) {
            ac.addObjects(_this.registeredObjects, objects);
          }
          return callback(err, objects);
        };
      })(this));
    };

    ManagedObjectContext.prototype.getObject = function(entityName, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      return this.getObjects(entityName, options, function(err, objects) {
        if (err) {
          return callback(err);
        }
        if (objects.length > 0) {
          return callback(null, objects[0]);
        } else {
          return callback(null, null);
        }
      });
    };

    ManagedObjectContext.prototype._getObjectsForRelationship = function(relationship, object, context, callback) {
      if (object.objectID.isTemporaryID) {
        return callback(null, []);
      }
      return this.storeCoordinator._valuesForForRelationship(relationship, object.objectID, context, function(err, objects) {
        return callback(err, objects);
      });
    };

    ManagedObjectContext.prototype.save = function(callback) {
      if (this.locked) {
        throw new Error('context is locked');
      }
      if (!this.hasChanges) {
        return callback(null);
      }
      this.locked = true;
      return this._processDeletedObjects((function(_this) {
        return function(err) {
          if (err) {
            _this.locked = false;
            return callback(err);
          }
          return _this.storeCoordinator.saveContext(_this, function(err) {
            var i, j, k, len, len1, len2, object, ref, ref1, ref2;
            if (!err) {
              ref = _this.insertedObjects;
              for (i = 0, len = ref.length; i < len; i++) {
                object = ref[i];
                object._changes = null;
                object._relationChanges = null;
                object._isInserted = false;
              }
              ref1 = _this.updatedObjects;
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                object = ref1[j];
                object._changes = null;
                object._relationChanges = null;
                object._isUpdated = false;
              }
              ref2 = _this.deletedObjects;
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                object = ref2[k];
                object._isDeleted = false;
              }
              _this.insertedObjects = [];
              _this.updatedObjects = [];
              _this.deletedObjects = [];
            }
            _this.locked = false;
            return callback(err);
          });
        };
      })(this));
    };

    ManagedObjectContext.prototype.reset = function() {
      if (this.locked) {
        throw new Error('context is locked');
      }
      this.registeredObjects = [];
      this.updatedObjects = [];
      return this.deletedObjects = [];
    };

    ManagedObjectContext.prototype.destroy = function() {
      if (this.locked) {
        throw new Error('context is locked');
      }
      delete this.registeredObjects;
      delete this.insertedObjects;
      delete this.updatedObjects;
      delete this.deletedObjects;
      return delete this.storeCoordinator;
    };

    Object.defineProperties(ManagedObjectContext.prototype, {
      hasChanges: {
        get: ManagedObjectContext.prototype.hasChanges
      }
    });

    ManagedObjectContext.prototype._processDeletedObjects = function(callback) {
      return async.forEach(this.deletedObjects, (function(_this) {
        return function(object, cb) {
          return object.prepareForDeletion(cb);
        };
      })(this), (function(_this) {
        return function(err) {
          var dels, i, len, obj, ref;
          if (err) {
            return callback(err);
          }
          dels = [];
          ref = _this.deletedObjects;
          for (i = 0, len = ref.length; i < len; i++) {
            obj = ref[i];
            dels.push(obj);
          }
          return async.forEach(dels, function(object, cb) {
            return _this._deleteObjectsRelationships(object, cb);
          }, callback);
        };
      })(this));
    };

    ManagedObjectContext.prototype._deleteObjectsRelationships = function(object, callback) {
      return async.forEach(object.entity.relationships, (function(_this) {
        return function(relationship, cb) {
          switch (relationship.deleteRule) {
            case RelationshipDescription.deleteRules.DENY:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                var canDelete, i, len, obj;
                if (err) {
                  return cb(err);
                }
                canDelete = true;
                if (objects.length > 0) {
                  for (i = 0, len = objects.length; i < len; i++) {
                    obj = objects[i];
                    canDelete = canDelete && obj.isDeleted;
                  }
                } else {
                  canDelete = true;
                }
                if (!canDelete) {
                  return cb(new Error('cannot delete object, deletion denied for relationship ' + relationship.entity.name + '->' + relationship.name));
                } else {
                  return cb();
                }
              });
            case RelationshipDescription.deleteRules.NULLIFY:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                var i, len, obj;
                if (err) {
                  return cb(err);
                }
                if (objects) {
                  for (i = 0, len = objects.length; i < len; i++) {
                    obj = objects[i];
                    object._removeObjectFromRelation(obj, relationship, relationship.inverseRelationship(), true, false);
                    obj._removeObjectFromRelation(object, relationship.inverseRelationship(), relationship, true, false);
                  }
                }
                return cb();
              });
            case RelationshipDescription.deleteRules.CASCADE:
              return _this._getObjectsForRelationship(relationship, object, _this, function(err, objects) {
                if (err) {
                  return cb(err);
                }
                if (objects) {
                  return async.forEach(objects, function(obj, _cb) {
                    _this._deleteObjectWithoutLockCheck(obj);
                    return _this._deleteObjectsRelationships(obj, _cb);
                  }, cb);
                } else {
                  return cb();
                }
              });
            default:
              return cb(new Error('not implemented ' + relationship.deleteRule));
          }
        };
      })(this), callback);
    };

    return ManagedObjectContext;

  })(Object);

  module.exports = ManagedObjectContext;

}).call(this);
