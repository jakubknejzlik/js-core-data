// Generated by CoffeeScript 1.6.3
(function() {
  var AttributeTransformer, IncrementalStore, ManagedObject, PersistentStoreCoordinator, PersistentStoreRequest, Predicate, ac, async,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  PersistentStoreRequest = require('./stores/PersistentStoreRequest');

  IncrementalStore = require('./stores/IncrementalStore');

  ManagedObject = require('./ManagedObject');

  Predicate = require('./FetchClasses/Predicate');

  async = require('async');

  ac = require('array-control');

  AttributeTransformer = require('./Helpers/AttributeTransformer');

  PersistentStoreCoordinator = (function(_super) {
    var registeredStoreTypes;

    __extends(PersistentStoreCoordinator, _super);

    PersistentStoreCoordinator.STORE_TYPE_MYSQL = 'MySQLStore';

    registeredStoreTypes = {};

    function PersistentStoreCoordinator(objectModel) {
      this.objectModel = objectModel;
      if (!this.objectModel) {
        throw new Error('Cannot create coordinator without object model');
      }
      this.persistentStores = [];
      this.waitingRequests = [];
      this.temporaryId = 1;
    }

    PersistentStoreCoordinator.registerStoreClass = function(storeClass, storeType) {
      registeredStoreTypes[storeType] = storeClass;
      return this;
    };

    PersistentStoreCoordinator.prototype.addStore = function(storeType, URL, callback) {
      var store,
        _this = this;
      store = new registeredStoreTypes[storeType](this, URL);
      return store.buildSchema(function(err) {
        if (!err) {
          _this.persistentStores.push(store);
        }
        if (callback) {
          return callback(err);
        }
      });
    };

    PersistentStoreCoordinator.prototype.execute = function(request, context, callback) {
      this.waitingRequests.push({
        request: request,
        context: context,
        callback: callback
      });
      return this._executeNextRequestIfPossible();
    };

    PersistentStoreCoordinator.prototype._executeNextRequestIfPossible = function() {
      var callback, context, info, obj, request, store, _ref,
        _this = this;
      if (this.executingRequest) {
        return;
      }
      info = this.waitingRequests.shift();
      if (!info) {
        return;
      }
      this.executingRequest = true;
      request = info.request;
      context = info.context;
      callback = info.callback;
      if (request.type === 'fetch' && ((_ref = request.predicate) != null ? _ref.isObjectIDPredicate() : void 0)) {
        obj = this._objectFromContextCache(context, request.predicate.objectID());
        if (obj) {
          return this._requestCompleted(callback, null, [obj]);
        }
      }
      store = this.persistentStores[0];
      return store.execute(request, context, function(err, ObjectIDs) {
        var objectID, objects, _i, _len;
        if (err) {
          return _this._requestCompleted(callback, err);
        }
        objects = [];
        for (_i = 0, _len = ObjectIDs.length; _i < _len; _i++) {
          objectID = ObjectIDs[_i];
          obj = _this._objectFromContextCache(context, objectID);
          if (obj) {
            objects.push(obj);
          } else {
            objects.push(_this._objectForID(request, context, objectID));
          }
        }
        return _this._requestCompleted(callback, null, objects);
      });
    };

    PersistentStoreCoordinator.prototype._requestCompleted = function(callback, err, objects) {
      this.executingRequest = false;
      callback(err, objects);
      return this._executeNextRequestIfPossible();
    };

    PersistentStoreCoordinator.prototype._objectForID = function(request, context, objectID) {
      var object, subclass;
      subclass = this.objectModel.subclassForEntity(request.entity.name);
      object = new subclass(request.entity, context);
      object._objectID = objectID;
      return object;
    };

    PersistentStoreCoordinator.prototype._objectFromContextCache = function(context, objectID) {
      var object, _i, _len, _ref;
      _ref = context.registeredObjects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.objectID.isEqual(objectID)) {
          return object;
        }
      }
      return null;
    };

    PersistentStoreCoordinator.prototype.saveContext = function(context, callback) {
      var obj, request, _i, _len, _ref,
        _this = this;
      request = new PersistentStoreRequest('save');
      request.insertedObjects = context.insertedObjects;
      request.updatedObjects = [];
      _ref = context.updatedObjects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (!ac.hasObject(request.insertedObjects, obj)) {
          request.updatedObjects.push(obj);
        }
      }
      request.deletedObjects = context.deletedObjects;
      return async.forEach(this.persistentStores, function(store, cb) {
        var _this = this;
        if (store instanceof IncrementalStore) {
          return store.execute(request, context, cb, function() {
            var i, object, permanentObjectIDs, _j, _len1, _ref1, _results;
            permanentObjectIDs = store.permanentIDsForObjects(context.insertedObjects);
            i = 0;
            _ref1 = context.insertedObjects;
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              object = _ref1[_j];
              object._objectID = permanentObjectIDs[i];
              _results.push(i++);
            }
            return _results;
          });
        } else {
          return cb(new Error('not an incremental store'));
        }
      }, function(err) {
        return callback(err);
      });
    };

    PersistentStoreCoordinator.prototype._valuesForForRelationship = function(relationship, ObjectID, context, callback) {
      var store,
        _this = this;
      store = this.persistentStores[0];
      return store.valuesForRelationship(relationship, ObjectID, context, function(err, ObjectIDs) {
        var objID, object, objects, subclass, _i, _len;
        if (err) {
          return callback(err);
        }
        if (relationship.toMany) {
          objects = [];
          for (_i = 0, _len = ObjectIDs.length; _i < _len; _i++) {
            objID = ObjectIDs[_i];
            object = _this._objectFromContextCache(context, objID);
            if (!object) {
              subclass = _this.objectModel.subclassForEntity(relationship.destinationEntity.name);
              object = new subclass(relationship.destinationEntity, context);
              object._objectID = objID;
            }
            ac.addObject(objects, object);
          }
          return callback(null, objects);
        } else {
          if (!ObjectIDs) {
            return callback(null, null);
          }
          object = _this._objectFromContextCache(context, ObjectIDs);
          if (!object) {
            subclass = _this.objectModel.subclassForEntity(relationship.destinationEntity.name);
            object = new subclass(relationship.destinationEntity, context);
            object._objectID = ObjectIDs;
          }
          return callback(null, object);
        }
      });
    };

    PersistentStoreCoordinator.prototype.temporaryObjectID = function(object) {
      var id;
      id = this.persistentStores[0].newObjectID(object.entity, this.temporaryId++);
      id.isTemporaryID = true;
      return id;
    };

    PersistentStoreCoordinator.prototype.valuesForObject = function(object) {
      var attributeDescription, values, _i, _len, _ref;
      values = this.persistentStores[0].valuesForObject(object.objectID, object.context);
      _ref = object.entity.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attributeDescription = _ref[_i];
        values[attributeDescription.name] = AttributeTransformer.transformValueForAttribute(values[attributeDescription.name], attributeDescription);
      }
      return values;
    };

    Object.defineProperties(PersistentStoreCoordinator.prototype, {
      registeredStoreTypes: {
        get: function() {
          return registeredStoreTypes;
        }
      }
    });

    return PersistentStoreCoordinator;

  })(Object);

  PersistentStoreCoordinator.registerStoreClass(require('./stores/Defaults/MySQLStore'), PersistentStoreCoordinator.STORE_TYPE_MYSQL);

  module.exports = PersistentStoreCoordinator;

}).call(this);
